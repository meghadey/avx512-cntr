#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

#define KBITS(K)    (sizeof(K))

#define vector(N)                                                       \
        {K##N, (KBITS(K##N)), IV##N, sizeof(IV##N), A##N, A##N##_len,   \
                        P##N, sizeof(P##N), C##N, T##N, sizeof(T##N)}

static const uint8_t K1_CTR[] = {
        0xAE, 0x68, 0x52, 0xF8, 0x12, 0x10, 0x67, 0xCC,
        0x4B, 0xF7, 0xA5, 0x76, 0x55, 0x77, 0xF3, 0x9E,
};
static const uint8_t IV1_CTR[] = {
        0x00, 0x00, 0x00, 0x30, /* nonce */
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
static const uint8_t P1_CTR[] = {
        0x53, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x20, 0x62,
        0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x6D, 0x73, 0x67,
};
static const uint8_t C1_CTR[] = {
        0xE4, 0x09, 0x5D, 0x4F, 0xB7, 0xA7, 0xB3, 0x79,
        0x2D, 0x61, 0x75, 0xA3, 0x26, 0x13, 0x11, 0xB8,
};
static const uint8_t T1_CTR[] = { 0 };
static const uint8_t A1_CTR[] = { 0 };

#define A1_CTR_len 0

static const uint8_t K2_CTR[] = {
        0x7E, 0x24, 0x06, 0x78, 0x17, 0xFA, 0xE0, 0xD7,
        0x43, 0xD6, 0xCE, 0x1F, 0x32, 0x53, 0x91, 0x63,
};
static const uint8_t IV2_CTR[] = {
        0x00, 0x6C, 0xB6, 0xDB, /* nonce */
        0xC0, 0x54, 0x3B, 0x59, 0xDA, 0x48, 0xD9, 0x0B,
};
static const uint8_t P2_CTR[] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
};
static const uint8_t C2_CTR[] = {
        0x51, 0x04, 0xA1, 0x06, 0x16, 0x8A, 0x72, 0xD9,
        0x79, 0x0D, 0x41, 0xEE, 0x8E, 0xDA, 0xD3, 0x88,
        0xEB, 0x2E, 0x1E, 0xFC, 0x46, 0xDA, 0x57, 0xC8,
        0xFC, 0xE6, 0x30, 0xDF, 0x91, 0x41, 0xBE, 0x28,
};
static const uint8_t T2_CTR[] = { 0 };
static const uint8_t A2_CTR[] = { 0 };
#define A2_CTR_len 0

static const uint8_t K3_CTR[] = {
        0x76, 0x91, 0xBE, 0x03, 0x5E, 0x50, 0x20, 0xA8,
        0xAC, 0x6E, 0x61, 0x85, 0x29, 0xF9, 0xA0, 0xDC,
};
static const uint8_t IV3_CTR[] = {
        0x00, 0xE0, 0x01, 0x7B, /* nonce */
        0x27, 0x77, 0x7F, 0x3F, 0x4A, 0x17, 0x86, 0xF0,
};
static const uint8_t P3_CTR[] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
        0x20, 0x21, 0x22, 0x23,
};
static const uint8_t C3_CTR[] = {
        0xC1, 0xCF, 0x48, 0xA8, 0x9F, 0x2F, 0xFD, 0xD9,
        0xCF, 0x46, 0x52, 0xE9, 0xEF, 0xDB, 0x72, 0xD7,
        0x45, 0x40, 0xA4, 0x2B, 0xDE, 0x6D, 0x78, 0x36,
        0xD5, 0x9A, 0x5C, 0xEA, 0xAE, 0xF3, 0x10, 0x53,
        0x25, 0xB2, 0x07, 0x2F,
};
static const uint8_t T3_CTR[] = { 0 };
static const uint8_t A3_CTR[] = { 0 };
#define A3_CTR_len 0

static const uint8_t K4_CTR[] = {
        0x16, 0xAF, 0x5B, 0x14, 0x5F, 0xC9, 0xF5, 0x79,
        0xC1, 0x75, 0xF9, 0x3E, 0x3B, 0xFB, 0x0E, 0xED,
        0x86, 0x3D, 0x06, 0xCC, 0xFD, 0xB7, 0x85, 0x15,
};
static const uint8_t IV4_CTR[] = {
        0x00, 0x00, 0x00, 0x48, /* nonce */
        0x36, 0x73, 0x3C, 0x14, 0x7D, 0x6D, 0x93, 0xCB,
};
static const uint8_t P4_CTR[] = {
        0x53, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x20, 0x62,
        0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x6D, 0x73, 0x67,
};
static const uint8_t C4_CTR[] = {
        0x4B, 0x55, 0x38, 0x4F, 0xE2, 0x59, 0xC9, 0xC8,
        0x4E, 0x79, 0x35, 0xA0, 0x03, 0xCB, 0xE9, 0x28,
};
static const uint8_t T4_CTR[] = { 0 };
static const uint8_t A4_CTR[] = { 0 };
#define A4_CTR_len 0

static const uint8_t K5_CTR[] = {
        0x7C, 0x5C, 0xB2, 0x40, 0x1B, 0x3D, 0xC3, 0x3C,
        0x19, 0xE7, 0x34, 0x08, 0x19, 0xE0, 0xF6, 0x9C,
        0x67, 0x8C, 0x3D, 0xB8, 0xE6, 0xF6, 0xA9, 0x1A,
};
static const uint8_t IV5_CTR[] = {
        0x00, 0x96, 0xB0, 0x3B, /* nonce */
        0x02, 0x0C, 0x6E, 0xAD, 0xC2, 0xCB, 0x50, 0x0D,
};
static const uint8_t P5_CTR[] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
};
static const uint8_t C5_CTR[] = {
        0x45, 0x32, 0x43, 0xFC, 0x60, 0x9B, 0x23, 0x32,
        0x7E, 0xDF, 0xAA, 0xFA, 0x71, 0x31, 0xCD, 0x9F,
        0x84, 0x90, 0x70, 0x1C, 0x5A, 0xD4, 0xA7, 0x9C,
        0xFC, 0x1F, 0xE0, 0xFF, 0x42, 0xF4, 0xFB, 0x00,
};
static const uint8_t T5_CTR[] = { 0 };
static const uint8_t A5_CTR[] = { 0 };
#define A5_CTR_len 0

static const uint8_t K6_CTR[] = {
        0x02, 0xBF, 0x39, 0x1E, 0xE8, 0xEC, 0xB1, 0x59,
        0xB9, 0x59, 0x61, 0x7B, 0x09, 0x65, 0x27, 0x9B,
        0xF5, 0x9B, 0x60, 0xA7, 0x86, 0xD3, 0xE0, 0xFE,
};
static const uint8_t IV6_CTR[] = {
        0x00, 0x07, 0xBD, 0xFD, /* nonce */
        0x5C, 0xBD, 0x60, 0x27, 0x8D, 0xCC, 0x09, 0x12,
};
static const uint8_t P6_CTR[] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
        0x20, 0x21, 0x22, 0x23,
};
static const uint8_t C6_CTR[] = {
        0x96, 0x89, 0x3F, 0xC5, 0x5E, 0x5C, 0x72, 0x2F,
        0x54, 0x0B, 0x7D, 0xD1, 0xDD, 0xF7, 0xE7, 0x58,
        0xD2, 0x88, 0xBC, 0x95, 0xC6, 0x91, 0x65, 0x88,
        0x45, 0x36, 0xC8, 0x11, 0x66, 0x2F, 0x21, 0x88,
        0xAB, 0xEE, 0x09, 0x35,
};
static const uint8_t T6_CTR[] = { 0 };
static const uint8_t A6_CTR[] = { 0 };
#define A6_CTR_len 0

static const uint8_t K7_CTR[] = {
        0x77, 0x6B, 0xEF, 0xF2, 0x85, 0x1D, 0xB0, 0x6F,
        0x4C, 0x8A, 0x05, 0x42, 0xC8, 0x69, 0x6F, 0x6C,
        0x6A, 0x81, 0xAF, 0x1E, 0xEC, 0x96, 0xB4, 0xD3,
        0x7F, 0xC1, 0xD6, 0x89, 0xE6, 0xC1, 0xC1, 0x04,
};
static const uint8_t IV7_CTR[] = {
        0x00, 0x00, 0x00, 0x60, /* nonce */
        0xDB, 0x56, 0x72, 0xC9, 0x7A, 0xA8, 0xF0, 0xB2,
};
static const uint8_t P7_CTR[] = {
        0x53, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x20, 0x62,
        0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x6D, 0x73, 0x67,
};
static const uint8_t C7_CTR[] = {
        0x14, 0x5A, 0xD0, 0x1D, 0xBF, 0x82, 0x4E, 0xC7,
        0x56, 0x08, 0x63, 0xDC, 0x71, 0xE3, 0xE0, 0xC0,
};
static const uint8_t T7_CTR[] = { 0 };
static const uint8_t A7_CTR[] = { 0 };
#define A7_CTR_len 0

static const uint8_t K8_CTR[] = {
        0xF6, 0xD6, 0x6D, 0x6B, 0xD5, 0x2D, 0x59, 0xBB,
        0x07, 0x96, 0x36, 0x58, 0x79, 0xEF, 0xF8, 0x86,
        0xC6, 0x6D, 0xD5, 0x1A, 0x5B, 0x6A, 0x99, 0x74,
        0x4B, 0x50, 0x59, 0x0C, 0x87, 0xA2, 0x38, 0x84,
};
static const uint8_t IV8_CTR[] = {
        0x00, 0xFA, 0xAC, 0x24, /* nonce */
        0xC1, 0x58, 0x5E, 0xF1, 0x5A, 0x43, 0xD8, 0x75,
};
static const uint8_t P8_CTR[] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
};
static const uint8_t C8_CTR[] = {
        0xF0, 0x5E, 0x23, 0x1B, 0x38, 0x94, 0x61, 0x2C,
        0x49, 0xEE, 0x00, 0x0B, 0x80, 0x4E, 0xB2, 0xA9,
        0xB8, 0x30, 0x6B, 0x50, 0x8F, 0x83, 0x9D, 0x6A,
        0x55, 0x30, 0x83, 0x1D, 0x93, 0x44, 0xAF, 0x1C,
};
static const uint8_t T8_CTR[] = { 0 };
static const uint8_t A8_CTR[] = { 0 };
#define A8_CTR_len 0

static const uint8_t K9_CTR[] = {
        0xFF, 0x7A, 0x61, 0x7C, 0xE6, 0x91, 0x48, 0xE4,
        0xF1, 0x72, 0x6E, 0x2F, 0x43, 0x58, 0x1D, 0xE2,
        0xAA, 0x62, 0xD9, 0xF8, 0x05, 0x53, 0x2E, 0xDF,
        0xF1, 0xEE, 0xD6, 0x87, 0xFB, 0x54, 0x15, 0x3D,
};
static const uint8_t IV9_CTR[] = {
        0x00, 0x1C, 0xC5, 0xB7, /* nonce */
        0x51, 0xA5, 0x1D, 0x70, 0xA1, 0xC1, 0x11, 0x48,
};
static const uint8_t P9_CTR[] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
        0x20, 0x21, 0x22, 0x23,
};
static const uint8_t C9_CTR[] = {
        0xEB, 0x6C, 0x52, 0x82, 0x1D, 0x0B, 0xBB, 0xF7,
        0xCE, 0x75, 0x94, 0x46, 0x2A, 0xCA, 0x4F, 0xAA,
        0xB4, 0x07, 0xDF, 0x86, 0x65, 0x69, 0xFD, 0x07,
        0xF4, 0x8C, 0xC0, 0xB5, 0x83, 0xD6, 0x07, 0x1F,
        0x1E, 0xC0, 0xE6, 0xB8,
};
static const uint8_t T9_CTR[] = { 0 };
static const uint8_t A9_CTR[] = { 0 };
#define A9_CTR_len 0

static const uint8_t K10_CTR[] = {
        0xAE, 0x68, 0x52, 0xF8, 0x12, 0x10, 0x67, 0xCC,
        0x4B, 0xF7, 0xA5, 0x76, 0x55, 0x77, 0xF3, 0x9E,
};
static const uint8_t IV10_CTR[] = {
        0x00, 0x00, 0x00, 0x30, /* nonce */
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
static const uint8_t P10_CTR[] = {
        0xA8, 0x63, 0x44, 0xF8, 0x36, 0x59, 0x2F, 0xF2,
        0xDA, 0xDD, 0x17, 0xCE, 0xFE, 0x2A, 0xF2, 0xA2,
        0x35, 0x87, 0x34, 0x0F, 0x35, 0xFC, 0xD8, 0xF2,
        0x57, 0xA1, 0xCB, 0x19, 0x0C, 0x33, 0x14, 0xE1,
        0x23, 0xEB, 0xC0, 0x88, 0x82, 0x05, 0x5F, 0x01,
        0x5D, 0xFC, 0x53, 0x08, 0xDB, 0x34, 0x8E, 0x94,
        0xE4, 0xA8, 0x26, 0x7F, 0xBC, 0xB7, 0x8B, 0xE1,
        0x58, 0x2F, 0x2C, 0x91, 0xCD, 0x5B, 0x4A, 0xAA,
        0x7A, 0xBA, 0x5F, 0xD2, 0x9B, 0xF8, 0x7D, 0xEA,
        0x76, 0xB6, 0x64, 0xB3, 0x29, 0xD3, 0x02, 0x19,
        0xA0, 0xDC, 0xE9, 0xB8, 0x90, 0x51, 0xA8, 0xDE,
        0x2E, 0xA1, 0xB7, 0x7E, 0x51, 0x0D, 0x34, 0xB3,
        0xED, 0xE7, 0x5E, 0xB8, 0x8A, 0xE9, 0xFE, 0x89,
        0xF8, 0x0B, 0x85, 0x09, 0x76, 0x08, 0x78, 0x0D,
        0x27, 0x59, 0x8E, 0x14, 0x43, 0x46, 0xA0, 0x91,
        0xEE, 0xAA, 0xFF, 0x74, 0x8D, 0xBC, 0x98, 0xB9
};

static const uint8_t C10_CTR[] = {
        0x1F, 0x03, 0x77, 0xD0, 0xED, 0x9B, 0xBC, 0xE9,
        0x9B, 0xD3, 0x01, 0x06, 0xF8, 0x54, 0x90, 0x7D,
        0x67, 0x6F, 0x19, 0xD7, 0x0B, 0xF3, 0x92, 0x8D,
        0x60, 0xC0, 0x18, 0x5A, 0x24, 0xC1, 0xD7, 0x60,
        0x82, 0x9C, 0x22, 0x37, 0x45, 0xE3, 0x9D, 0xA6,
        0x76, 0x37, 0xE1, 0x7A, 0x13, 0xB4, 0x40, 0x63,
        0xF4, 0xD8, 0xDE, 0x41, 0x64, 0xFC, 0xE2, 0x42,
        0x2E, 0x3F, 0xEA, 0xE1, 0x28, 0x06, 0xA5, 0xAC,
        0x6A, 0xC1, 0x58, 0x0C, 0x84, 0xFF, 0x9B, 0x6A,
        0xE5, 0xBE, 0x4E, 0x8C, 0x4C, 0xE9, 0x97, 0xD5,
        0x24, 0x30, 0x1B, 0x19, 0xDF, 0x87, 0x56, 0x85,
        0x31, 0x56, 0x5A, 0xDE, 0xE0, 0x6E, 0xC0, 0x1C,
        0xCB, 0x51, 0x5B, 0x6E, 0xAC, 0xF5, 0xB0, 0x60,
        0x60, 0x2F, 0x62, 0x0A, 0xEA, 0x62, 0x51, 0x2E,
        0x5B, 0x1B, 0x99, 0x51, 0x3B, 0xAC, 0xE9, 0xC5,
        0x59, 0x7D, 0x0E, 0xB6, 0x51, 0x6C, 0x16, 0x7A
};

static const uint8_t T10_CTR[] = { 0 };
static const uint8_t A10_CTR[] = { 0 };
#define A10_CTR_len 0

static const uint8_t K11_CTR[] = {
        0xAE, 0x68, 0x52, 0xF8, 0x12, 0x10, 0x67, 0xCC,
        0x4B, 0xF7, 0xA5, 0x76, 0x55, 0x77, 0xF3, 0x9E,
};
static const uint8_t IV11_CTR[] = {
        0x00, 0x00, 0x00, 0x30, /* nonce */
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
static const uint8_t P11_CTR[] = {
        0xA8, 0x63, 0x44, 0xF8, 0x36, 0x59, 0x2F, 0xF2,
        0xDA, 0xDD, 0x17, 0xCE, 0xFE, 0x2A, 0xF2, 0xA2,
        0x35, 0x87, 0x34, 0x0F, 0x35, 0xFC, 0xD8, 0xF2,
        0x57, 0xA1, 0xCB, 0x19, 0x0C, 0x33, 0x14, 0xE1,
        0x23, 0xEB, 0xC0, 0x88, 0x82, 0x05, 0x5F, 0x01,
        0x5D, 0xFC, 0x53, 0x08, 0xDB, 0x34, 0x8E, 0x94,
        0xE4, 0xA8, 0x26, 0x7F, 0xBC, 0xB7, 0x8B, 0xE1,
        0x58, 0x2F, 0x2C, 0x91, 0xCD, 0x5B, 0x4A, 0xAA,
        0x7A, 0xBA, 0x5F, 0xD2, 0x9B, 0xF8, 0x7D, 0xEA,
        0x76, 0xB6, 0x64, 0xB3, 0x29, 0xD3, 0x02, 0x19,
        0xA0, 0xDC, 0xE9, 0xB8, 0x90, 0x51, 0xA8, 0xDE,
        0x2E, 0xA1, 0xB7, 0x7E, 0x51, 0x0D, 0x34, 0xB3,
        0xED, 0xE7, 0x5E, 0xB8, 0x8A, 0xE9, 0xFE, 0x89,
        0xF8, 0x0B, 0x85, 0x09, 0x76, 0x08, 0x78, 0x0D,
        0x27, 0x59, 0x8E, 0x14, 0x43, 0x46, 0xA0, 0x91,
        0xEE, 0xAA, 0xFF, 0x74, 0x8D, 0xBC, 0x98, 0xB9,
        0x12, 0xAD, 0x82, 0xDF, 0x2F, 0xF8, 0x9C, 0xE0
};

static const uint8_t C11_CTR[] = {
        0x1F, 0x03, 0x77, 0xD0, 0xED, 0x9B, 0xBC, 0xE9,
        0x9B, 0xD3, 0x01, 0x06, 0xF8, 0x54, 0x90, 0x7D,
        0x67, 0x6F, 0x19, 0xD7, 0x0B, 0xF3, 0x92, 0x8D,
        0x60, 0xC0, 0x18, 0x5A, 0x24, 0xC1, 0xD7, 0x60,
        0x82, 0x9C, 0x22, 0x37, 0x45, 0xE3, 0x9D, 0xA6,
        0x76, 0x37, 0xE1, 0x7A, 0x13, 0xB4, 0x40, 0x63,
        0xF4, 0xD8, 0xDE, 0x41, 0x64, 0xFC, 0xE2, 0x42,
        0x2E, 0x3F, 0xEA, 0xE1, 0x28, 0x06, 0xA5, 0xAC,
        0x6A, 0xC1, 0x58, 0x0C, 0x84, 0xFF, 0x9B, 0x6A,
        0xE5, 0xBE, 0x4E, 0x8C, 0x4C, 0xE9, 0x97, 0xD5,
        0x24, 0x30, 0x1B, 0x19, 0xDF, 0x87, 0x56, 0x85,
        0x31, 0x56, 0x5A, 0xDE, 0xE0, 0x6E, 0xC0, 0x1C,
        0xCB, 0x51, 0x5B, 0x6E, 0xAC, 0xF5, 0xB0, 0x60,
        0x60, 0x2F, 0x62, 0x0A, 0xEA, 0x62, 0x51, 0x2E,
        0x5B, 0x1B, 0x99, 0x51, 0x3B, 0xAC, 0xE9, 0xC5,
        0x59, 0x7D, 0x0E, 0xB6, 0x51, 0x6C, 0x16, 0x7A,
        0x7A, 0x13, 0xB4, 0x40, 0x69, 0x9B, 0x58, 0x16
};
static const uint8_t T11_CTR[] = { 0 };
static const uint8_t A11_CTR[] = { 0 };
#define A11_CTR_len 0

static const uint8_t K12_CTR[] = {
        0xAE, 0x68, 0x52, 0xF8, 0x12, 0x10, 0x67, 0xCC,
        0x4B, 0xF7, 0xA5, 0x76, 0x55, 0x77, 0xF3, 0x9E,
};
static const uint8_t IV12_CTR[] = {
        0x00, 0x00, 0x00, 0x30, /* nonce */
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
static const uint8_t P12_CTR[] = {
        0xA8, 0x63, 0x44, 0xF8, 0x36, 0x59, 0x2F, 0xF2,
        0xDA, 0xDD, 0x17, 0xCE, 0xFE, 0x2A, 0xF2, 0xA2,
        0x35, 0x87, 0x34, 0x0F, 0x35, 0xFC, 0xD8, 0xF2,
        0x57, 0xA1, 0xCB, 0x19, 0x0C, 0x33, 0x14, 0xE1,
        0x23, 0xEB, 0xC0, 0x88, 0x82, 0x05, 0x5F, 0x01,
        0x5D, 0xFC, 0x53, 0x08, 0xDB, 0x34, 0x8E, 0x94,
        0xE4, 0xA8, 0x26, 0x7F, 0xBC, 0xB7, 0x8B, 0xE1,
        0x58, 0x2F, 0x2C, 0x91, 0xCD, 0x5B, 0x4A, 0xAA,
        0x7A, 0xBA, 0x5F, 0xD2, 0x9B, 0xF8, 0x7D, 0xEA,
        0x76, 0xB6, 0x64, 0xB3, 0x29, 0xD3, 0x02, 0x19,
        0xA0, 0xDC, 0xE9, 0xB8, 0x90, 0x51, 0xA8, 0xDE,
        0x2E, 0xA1, 0xB7, 0x7E, 0x51, 0x0D, 0x34, 0xB3,
        0xED, 0xE7, 0x5E, 0xB8, 0x8A, 0xE9, 0xFE, 0x89,
        0xF8, 0x0B, 0x85, 0x09, 0x76, 0x08, 0x78, 0x0D,
        0x27, 0x59, 0x8E, 0x14, 0x43, 0x46, 0xA0, 0x91,
        0xEE, 0xAA, 0xFF, 0x74, 0x8D, 0xBC, 0x98, 0xB9,
        0x77, 0xBD, 0x41, 0x4F, 0xAB, 0xF8, 0x78, 0x1F,
        0xED, 0x2B, 0x14, 0x89, 0xB5, 0x7B, 0x61, 0x5E,
        0x88, 0x35, 0x46, 0x0F, 0x83, 0x5B, 0xC6, 0xE6,
        0x61, 0x1D, 0xD8, 0x5E, 0xD3, 0xC3, 0xC6, 0xE8,
        0xFB, 0x8E, 0x59, 0xDB, 0x31, 0x17, 0xF8, 0xCD,
        0xC1, 0xD4, 0x2D, 0xEF, 0xD8, 0x25, 0x9E, 0x88,
        0x10, 0x58, 0xF2, 0xA6, 0x84, 0x4F, 0xA1, 0x32,
        0x5F, 0x0E, 0xA2, 0x14, 0xF7, 0x03, 0x85, 0x06,
        0x94, 0x4F, 0x83, 0x87, 0x04, 0x97, 0x5A, 0x8D,
        0x9A, 0x73, 0x36, 0x2A, 0xE0, 0x6D, 0xA9, 0x1F,
        0xBC, 0x2F, 0xD2, 0x9E, 0xD1, 0x7D, 0x2C, 0x89,
        0x1F, 0xE1, 0xA0, 0x8F, 0x5D, 0x3E, 0xAB, 0x9E,
        0x79, 0x1A, 0x76, 0xC3, 0x0A, 0xC8, 0xCF, 0xCB,
        0x35, 0x63, 0xD9, 0x46, 0x87, 0xAF, 0x74, 0x24,
        0x47, 0xBA, 0x60, 0xAB, 0x33, 0x5D, 0xA8, 0xDE,
        0xFE, 0x1B, 0xC5, 0x3F, 0xAC, 0xD9, 0xAD, 0x94
};

static const uint8_t C12_CTR[] = {
        0x1F, 0x03, 0x77, 0xD0, 0xED, 0x9B, 0xBC, 0xE9,
        0x9B, 0xD3, 0x01, 0x06, 0xF8, 0x54, 0x90, 0x7D,
        0x67, 0x6F, 0x19, 0xD7, 0x0B, 0xF3, 0x92, 0x8D,
        0x60, 0xC0, 0x18, 0x5A, 0x24, 0xC1, 0xD7, 0x60,
        0x82, 0x9C, 0x22, 0x37, 0x45, 0xE3, 0x9D, 0xA6,
        0x76, 0x37, 0xE1, 0x7A, 0x13, 0xB4, 0x40, 0x63,
        0xF4, 0xD8, 0xDE, 0x41, 0x64, 0xFC, 0xE2, 0x42,
        0x2E, 0x3F, 0xEA, 0xE1, 0x28, 0x06, 0xA5, 0xAC,
        0x6A, 0xC1, 0x58, 0x0C, 0x84, 0xFF, 0x9B, 0x6A,
        0xE5, 0xBE, 0x4E, 0x8C, 0x4C, 0xE9, 0x97, 0xD5,
        0x24, 0x30, 0x1B, 0x19, 0xDF, 0x87, 0x56, 0x85,
        0x31, 0x56, 0x5A, 0xDE, 0xE0, 0x6E, 0xC0, 0x1C,
        0xCB, 0x51, 0x5B, 0x6E, 0xAC, 0xF5, 0xB0, 0x60,
        0x60, 0x2F, 0x62, 0x0A, 0xEA, 0x62, 0x51, 0x2E,
        0x5B, 0x1B, 0x99, 0x51, 0x3B, 0xAC, 0xE9, 0xC5,
        0x59, 0x7D, 0x0E, 0xB6, 0x51, 0x6C, 0x16, 0x7A,
        0x1F, 0x03, 0x77, 0xD0, 0xED, 0x9B, 0xBC, 0xE9,
        0x9B, 0xD3, 0x01, 0x06, 0xF8, 0x54, 0x90, 0x7D,
        0x67, 0x6F, 0x19, 0xD7, 0x0B, 0xF3, 0x92, 0x8D,
        0x60, 0xC0, 0x18, 0x5A, 0x24, 0xC1, 0xD7, 0x60,
        0x82, 0x9C, 0x22, 0x37, 0x45, 0xE3, 0x9D, 0xA6,
        0x76, 0x37, 0xE1, 0x7A, 0x13, 0xB4, 0x40, 0x63,
        0xF4, 0xD8, 0xDE, 0x41, 0x64, 0xFC, 0xE2, 0x42,
        0x2E, 0x3F, 0xEA, 0xE1, 0x28, 0x06, 0xA5, 0xAC,
        0x6A, 0xC1, 0x58, 0x0C, 0x84, 0xFF, 0x9B, 0x6A,
        0xE5, 0xBE, 0x4E, 0x8C, 0x4C, 0xE9, 0x97, 0xD5,
        0x24, 0x30, 0x1B, 0x19, 0xDF, 0x87, 0x56, 0x85,
        0x31, 0x56, 0x5A, 0xDE, 0xE0, 0x6E, 0xC0, 0x1C,
        0xCB, 0x51, 0x5B, 0x6E, 0xAC, 0xF5, 0xB0, 0x60,
        0x60, 0x2F, 0x62, 0x0A, 0xEA, 0x62, 0x51, 0x2E,
        0x5B, 0x1B, 0x99, 0x51, 0x3B, 0xAC, 0xE9, 0xC5,
        0x59, 0x7D, 0x0E, 0xB6, 0x51, 0x6C, 0x16, 0x7A,
};
static const uint8_t T12_CTR[] = { 0 };
static const uint8_t A12_CTR[] = { 0 };
#define A12_CTR_len 0

static const uint8_t K13_CTR[] = {
        0xAE, 0x68, 0x52, 0xF8, 0x12, 0x10, 0x67, 0xCC,
        0x4B, 0xF7, 0xA5, 0x76, 0x55, 0x77, 0xF3, 0x9E,
};
static const uint8_t IV13_CTR[] = {
        0x00, 0x00, 0x00, 0x30, /* nonce */
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
static const uint8_t P13_CTR[] = {
	        0xA8, 0x63, 0x44, 0xF8, 0x36, 0x59, 0x2F, 0xF2,
        0xDA, 0xDD, 0x17, 0xCE, 0xFE, 0x2A, 0xF2, 0xA2,
        0x35, 0x87, 0x34, 0x0F, 0x35, 0xFC, 0xD8, 0xF2,
        0x57, 0xA1, 0xCB, 0x19, 0x0C, 0x33, 0x14, 0xE1,
        0x23, 0xEB, 0xC0, 0x88, 0x82, 0x05, 0x5F, 0x01,
        0x5D, 0xFC, 0x53, 0x08, 0xDB, 0x34, 0x8E, 0x94,
        0xE4, 0xA8, 0x26, 0x7F, 0xBC, 0xB7, 0x8B, 0xE1,
        0x58, 0x2F, 0x2C, 0x91, 0xCD, 0x5B, 0x4A, 0xAA,
        0x7A, 0xBA, 0x5F, 0xD2, 0x9B, 0xF8, 0x7D, 0xEA,
        0x76, 0xB6, 0x64, 0xB3, 0x29, 0xD3, 0x02, 0x19,
        0xA0, 0xDC, 0xE9, 0xB8, 0x90, 0x51, 0xA8, 0xDE,
        0x2E, 0xA1, 0xB7, 0x7E, 0x51, 0x0D, 0x34, 0xB3,
        0xED, 0xE7, 0x5E, 0xB8, 0x8A, 0xE9, 0xFE, 0x89,
        0xF8, 0x0B, 0x85, 0x09, 0x76, 0x08, 0x78, 0x0D,
        0x27, 0x59, 0x8E, 0x14, 0x43, 0x46, 0xA0, 0x91,
        0xEE, 0xAA, 0xFF, 0x74, 0x8D, 0xBC, 0x98, 0xB9,
        0x77, 0xBD, 0x41, 0x4F, 0xAB, 0xF8, 0x78, 0x1F,
        0xED, 0x2B, 0x14, 0x89, 0xB5, 0x7B, 0x61, 0x5E,
        0x88, 0x35, 0x46, 0x0F, 0x83, 0x5B, 0xC6, 0xE6,
        0x61, 0x1D, 0xD8, 0x5E, 0xD3, 0xC3, 0xC6, 0xE8,
        0xFB, 0x8E, 0x59, 0xDB, 0x31, 0x17, 0xF8, 0xCD,
        0xC1, 0xD4, 0x2D, 0xEF, 0xD8, 0x25, 0x9E, 0x88,
        0x10, 0x58, 0xF2, 0xA6, 0x84, 0x4F, 0xA1, 0x32,
        0x5F, 0x0E, 0xA2, 0x14, 0xF7, 0x03, 0x85, 0x06,
        0x94, 0x4F, 0x83, 0x87, 0x04, 0x97, 0x5A, 0x8D,
        0x9A, 0x73, 0x36, 0x2A, 0xE0, 0x6D, 0xA9, 0x1F,
        0xBC, 0x2F, 0xD2, 0x9E, 0xD1, 0x7D, 0x2C, 0x89,
        0x1F, 0xE1, 0xA0, 0x8F, 0x5D, 0x3E, 0xAB, 0x9E,
        0x79, 0x1A, 0x76, 0xC3, 0x0A, 0xC8, 0xCF, 0xCB,
        0x35, 0x63, 0xD9, 0x46, 0x87, 0xAF, 0x74, 0x24,
        0x47, 0xBA, 0x60, 0xAB, 0x33, 0x5D, 0xA8, 0xDE,
        0xFE, 0x1B, 0xC5, 0x3F, 0xAC, 0xD9, 0xAD, 0x94,
        0x66, 0xb8, 0x3f, 0x3a, 0x21, 0x9f, 0xd0, 0x43,
        0x46, 0xdd, 0x65, 0x8b, 0x44, 0x99, 0x66, 0x91,
        0x64, 0xe2, 0x69, 0x6f, 0xbb, 0x85, 0x8c, 0xcc,
        0x7f, 0xea, 0x96, 0xd1, 0x5e, 0xb4, 0x7c, 0xd0,
        0xab, 0x02, 0x8d, 0xa3, 0x59, 0x3b, 0x8c, 0xd5,
        0xd0, 0xe7, 0xb4, 0xc4
};

static const uint8_t C13_CTR[] = {
        0x1F, 0x03, 0x77, 0xD0, 0xED, 0x9B, 0xBC, 0xE9,
        0x9B, 0xD3, 0x01, 0x06, 0xF8, 0x54, 0x90, 0x7D,
        0x67, 0x6F, 0x19, 0xD7, 0x0B, 0xF3, 0x92, 0x8D,
        0x60, 0xC0, 0x18, 0x5A, 0x24, 0xC1, 0xD7, 0x60,
        0x82, 0x9C, 0x22, 0x37, 0x45, 0xE3, 0x9D, 0xA6,
        0x76, 0x37, 0xE1, 0x7A, 0x13, 0xB4, 0x40, 0x63,
        0xF4, 0xD8, 0xDE, 0x41, 0x64, 0xFC, 0xE2, 0x42,
        0x2E, 0x3F, 0xEA, 0xE1, 0x28, 0x06, 0xA5, 0xAC,
        0x6A, 0xC1, 0x58, 0x0C, 0x84, 0xFF, 0x9B, 0x6A,
        0xE5, 0xBE, 0x4E, 0x8C, 0x4C, 0xE9, 0x97, 0xD5,
        0x24, 0x30, 0x1B, 0x19, 0xDF, 0x87, 0x56, 0x85,
        0x31, 0x56, 0x5A, 0xDE, 0xE0, 0x6E, 0xC0, 0x1C,
        0xCB, 0x51, 0x5B, 0x6E, 0xAC, 0xF5, 0xB0, 0x60,
        0x60, 0x2F, 0x62, 0x0A, 0xEA, 0x62, 0x51, 0x2E,
        0x5B, 0x1B, 0x99, 0x51, 0x3B, 0xAC, 0xE9, 0xC5,
        0x59, 0x7D, 0x0E, 0xB6, 0x51, 0x6C, 0x16, 0x7A,
        0x1F, 0x03, 0x77, 0xD0, 0xED, 0x9B, 0xBC, 0xE9,
        0x9B, 0xD3, 0x01, 0x06, 0xF8, 0x54, 0x90, 0x7D,
        0x67, 0x6F, 0x19, 0xD7, 0x0B, 0xF3, 0x92, 0x8D,
        0x60, 0xC0, 0x18, 0x5A, 0x24, 0xC1, 0xD7, 0x60,
        0x82, 0x9C, 0x22, 0x37, 0x45, 0xE3, 0x9D, 0xA6,
        0x76, 0x37, 0xE1, 0x7A, 0x13, 0xB4, 0x40, 0x63,
        0xF4, 0xD8, 0xDE, 0x41, 0x64, 0xFC, 0xE2, 0x42,
        0x2E, 0x3F, 0xEA, 0xE1, 0x28, 0x06, 0xA5, 0xAC,
        0x6A, 0xC1, 0x58, 0x0C, 0x84, 0xFF, 0x9B, 0x6A,
        0xE5, 0xBE, 0x4E, 0x8C, 0x4C, 0xE9, 0x97, 0xD5,
        0x24, 0x30, 0x1B, 0x19, 0xDF, 0x87, 0x56, 0x85,
        0x31, 0x56, 0x5A, 0xDE, 0xE0, 0x6E, 0xC0, 0x1C,
        0xCB, 0x51, 0x5B, 0x6E, 0xAC, 0xF5, 0xB0, 0x60,
        0x60, 0x2F, 0x62, 0x0A, 0xEA, 0x62, 0x51, 0x2E,
        0x5B, 0x1B, 0x99, 0x51, 0x3B, 0xAC, 0xE9, 0xC5,
        0x59, 0x7D, 0x0E, 0xB6, 0x51, 0x6C, 0x16, 0x7A,
        0xED, 0x52, 0x55, 0xB9, 0x76, 0x6C, 0x5E, 0x6E,
        0x76, 0x97, 0x00, 0xC7, 0xEB, 0xFE, 0xEC, 0x10,
        0x94, 0x2C, 0xA9, 0xAF, 0x9B, 0x09, 0x19, 0xB3,
        0x17, 0x29, 0x96, 0xBA, 0x8E, 0xAC, 0x3D, 0x0A,
        0x9B, 0x70, 0x54, 0x0F, 0x1E, 0xD4, 0xE8, 0x13,
        0xE6, 0x8F, 0xAD, 0xFD

};
static const uint8_t T13_CTR[] = { 0 };
static const uint8_t A13_CTR[] = { 0 };
#define A13_CTR_len 0

static const uint8_t K14_CTR[] = {
        0xAE, 0x68, 0x52, 0xF8, 0x12, 0x10, 0x67, 0xCC,
        0x4B, 0xF7, 0xA5, 0x76, 0x55, 0x77, 0xF3, 0x9E,
};
static const uint8_t IV14_CTR[] = {
        0x00, 0x00, 0x00, 0x30, /* nonce */
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
static const uint8_t P14_CTR[] = {
        0xA8, 0x63, 0x44, 0xF8, 0x36, 0x59, 0x2F, 0xF2,
        0xDA, 0xDD, 0x17, 0xCE, 0xFE, 0x2A, 0xF2, 0xA2,
        0x35, 0x87, 0x34, 0x0F, 0x35, 0xFC, 0xD8, 0xF2,
        0x57, 0xA1, 0xCB, 0x19, 0x0C, 0x33, 0x14, 0xE1,
        0x23, 0xEB, 0xC0, 0x88, 0x82, 0x05, 0x5F, 0x01,
        0x5D, 0xFC, 0x53, 0x08, 0xDB, 0x34, 0x8E, 0x94,
        0xE4, 0xA8, 0x26, 0x7F, 0xBC, 0xB7, 0x8B, 0xE1,
        0x58, 0x2F, 0x2C, 0x91, 0xCD, 0x5B, 0x4A, 0xAA,
        0x7A, 0xBA, 0x5F, 0xD2, 0x9B, 0xF8, 0x7D, 0xEA,
        0x76, 0xB6, 0x64, 0xB3, 0x29, 0xD3, 0x02, 0x19,
        0xA0, 0xDC, 0xE9, 0xB8, 0x90, 0x51, 0xA8, 0xDE,
        0x2E, 0xA1, 0xB7, 0x7E, 0x51, 0x0D, 0x34, 0xB3,
        0xED, 0xE7, 0x5E, 0xB8, 0x8A, 0xE9, 0xFE, 0x89,
        0xF8, 0x0B, 0x85, 0x09, 0x76, 0x08, 0x78, 0x0D,
        0x27, 0x59, 0x8E, 0x14, 0x43, 0x46, 0xA0, 0x91,
        0xEE, 0xAA, 0xFF, 0x74, 0x8D, 0xBC, 0x98, 0xB9,
        0x77, 0xBD, 0x41, 0x4F, 0xAB, 0xF8, 0x78, 0x1F,
        0xED, 0x2B, 0x14, 0x89, 0xB5, 0x7B, 0x61, 0x5E,
        0x88, 0x35, 0x46, 0x0F, 0x83, 0x5B, 0xC6, 0xE6,
        0x61, 0x1D, 0xD8, 0x5E, 0xD3, 0xC3, 0xC6, 0xE8,
        0xFB, 0x8E, 0x59, 0xDB, 0x31, 0x17, 0xF8, 0xCD,
        0xC1, 0xD4, 0x2D, 0xEF, 0xD8, 0x25, 0x9E, 0x88,
        0x10, 0x58, 0xF2, 0xA6, 0x84, 0x4F, 0xA1, 0x32,
        0x5F, 0x0E, 0xA2, 0x14, 0xF7, 0x03, 0x85, 0x06,
        0x94, 0x4F, 0x83, 0x87, 0x04, 0x97, 0x5A, 0x8D,
        0x9A, 0x73, 0x36, 0x2A, 0xE0, 0x6D, 0xA9, 0x1F,
        0xBC, 0x2F, 0xD2, 0x9E, 0xD1, 0x7D, 0x2C, 0x89,
        0x1F, 0xE1, 0xA0, 0x8F, 0x5D, 0x3E, 0xAB, 0x9E,
        0x79, 0x1A, 0x76, 0xC3, 0x0A, 0xC8, 0xCF, 0xCB,
        0x35, 0x63, 0xD9, 0x46, 0x87, 0xAF, 0x74, 0x24,
        0x47, 0xBA, 0x60, 0xAB, 0x33, 0x5D, 0xA8, 0xDE,
        0xFE, 0x1B, 0xC5, 0x3F, 0xAC, 0xD9, 0xAD, 0x94,
        0x66, 0xb8, 0x3f, 0x3a, 0x21, 0x9f, 0xd0, 0x43,
        0x46, 0xdd, 0x65, 0x8b, 0x44, 0x99, 0x66, 0x91,
        0x64, 0xe2, 0x69, 0x6f, 0xbb, 0x85, 0x8c, 0xcc,
        0x7f, 0xea, 0x96, 0xd1, 0x5e, 0xb4, 0x7c, 0xd0,
        0xab, 0x02, 0x8d, 0xa3, 0x59, 0x3b, 0x8c, 0xd5,
        0xd0, 0xe7, 0xb4, 0xc4, 0x90, 0x41, 0x9f, 0x78,
        0x4e, 0x82, 0x9e, 0xe4, 0x1b, 0x97, 0xa9, 0xa4,
        0x7b, 0x48, 0xad, 0x56, 0xc0, 0xe4, 0x86, 0x52,
        0xfc, 0xad, 0x93, 0x0b, 0x7d, 0x38, 0xce, 0x73,
        0x64, 0xbd, 0xf7, 0x00, 0x7b, 0xe6, 0x46, 0x03,
        0x2f, 0x4b, 0x75, 0x9f, 0x3a, 0x2d, 0x32, 0x42,
        0xfe, 0x80, 0x74, 0x89, 0x27, 0x34, 0xce, 0x5e,
        0xbf, 0xbe, 0x07, 0x50, 0x91, 0x08, 0x27, 0x2b,
        0x32, 0x77, 0xa7, 0xff, 0x83, 0xb1, 0xab, 0xc8,
        0x98, 0xbe, 0xac, 0x33, 0x7c, 0x47, 0x19, 0x33,
        0x6f, 0x4d, 0xbe, 0x3e, 0xdc, 0xe0, 0x87, 0xfb
};
static const uint8_t C14_CTR[] = {
        0x1F, 0x03, 0x77, 0xD0, 0xED, 0x9B, 0xBC, 0xE9,
        0x9B, 0xD3, 0x01, 0x06, 0xF8, 0x54, 0x90, 0x7D,
        0x67, 0x6F, 0x19, 0xD7, 0x0B, 0xF3, 0x92, 0x8D,
        0x60, 0xC0, 0x18, 0x5A, 0x24, 0xC1, 0xD7, 0x60,
        0x82, 0x9C, 0x22, 0x37, 0x45, 0xE3, 0x9D, 0xA6,
        0x76, 0x37, 0xE1, 0x7A, 0x13, 0xB4, 0x40, 0x63,
        0xF4, 0xD8, 0xDE, 0x41, 0x64, 0xFC, 0xE2, 0x42,
        0x2E, 0x3F, 0xEA, 0xE1, 0x28, 0x06, 0xA5, 0xAC,
        0x6A, 0xC1, 0x58, 0x0C, 0x84, 0xFF, 0x9B, 0x6A,
        0xE5, 0xBE, 0x4E, 0x8C, 0x4C, 0xE9, 0x97, 0xD5,
        0x24, 0x30, 0x1B, 0x19, 0xDF, 0x87, 0x56, 0x85,
        0x31, 0x56, 0x5A, 0xDE, 0xE0, 0x6E, 0xC0, 0x1C,
        0xCB, 0x51, 0x5B, 0x6E, 0xAC, 0xF5, 0xB0, 0x60,
        0x60, 0x2F, 0x62, 0x0A, 0xEA, 0x62, 0x51, 0x2E,
        0x5B, 0x1B, 0x99, 0x51, 0x3B, 0xAC, 0xE9, 0xC5,
        0x59, 0x7D, 0x0E, 0xB6, 0x51, 0x6C, 0x16, 0x7A,
        0x1F, 0x03, 0x77, 0xD0, 0xED, 0x9B, 0xBC, 0xE9,
        0x9B, 0xD3, 0x01, 0x06, 0xF8, 0x54, 0x90, 0x7D,
        0x67, 0x6F, 0x19, 0xD7, 0x0B, 0xF3, 0x92, 0x8D,
        0x60, 0xC0, 0x18, 0x5A, 0x24, 0xC1, 0xD7, 0x60,
        0x82, 0x9C, 0x22, 0x37, 0x45, 0xE3, 0x9D, 0xA6,
        0x76, 0x37, 0xE1, 0x7A, 0x13, 0xB4, 0x40, 0x63,
        0xF4, 0xD8, 0xDE, 0x41, 0x64, 0xFC, 0xE2, 0x42,
        0x2E, 0x3F, 0xEA, 0xE1, 0x28, 0x06, 0xA5, 0xAC,
        0x6A, 0xC1, 0x58, 0x0C, 0x84, 0xFF, 0x9B, 0x6A,
        0xE5, 0xBE, 0x4E, 0x8C, 0x4C, 0xE9, 0x97, 0xD5,
        0x24, 0x30, 0x1B, 0x19, 0xDF, 0x87, 0x56, 0x85,
        0x31, 0x56, 0x5A, 0xDE, 0xE0, 0x6E, 0xC0, 0x1C,
        0xCB, 0x51, 0x5B, 0x6E, 0xAC, 0xF5, 0xB0, 0x60,
        0x60, 0x2F, 0x62, 0x0A, 0xEA, 0x62, 0x51, 0x2E,
        0x5B, 0x1B, 0x99, 0x51, 0x3B, 0xAC, 0xE9, 0xC5,
        0x59, 0x7D, 0x0E, 0xB6, 0x51, 0x6C, 0x16, 0x7A,
        0xED, 0x52, 0x55, 0xB9, 0x76, 0x6C, 0x5E, 0x6E,
        0x76, 0x97, 0x00, 0xC7, 0xEB, 0xFE, 0xEC, 0x10,
        0x94, 0x2C, 0xA9, 0xAF, 0x9B, 0x09, 0x19, 0xB3,
        0x17, 0x29, 0x96, 0xBA, 0x8E, 0xAC, 0x3D, 0x0A,
        0x9B, 0x70, 0x54, 0x0F, 0x1E, 0xD4, 0xE8, 0x13,
        0xE6, 0x8F, 0xAD, 0xFD, 0xFD, 0x13, 0xCF, 0xD5,
        0x94, 0x06, 0xA0, 0x24, 0x79, 0xC0, 0xF8, 0x05,
        0x3D, 0x19, 0xEB, 0x96, 0xDA, 0x31, 0xAE, 0xF5,
        0x4D, 0x82, 0x2C, 0x23, 0x03, 0x9A, 0x43, 0x85,
        0x94, 0x36, 0x30, 0xE8, 0x0A, 0x9B, 0x1F, 0x05,
        0x6E, 0x4B, 0xA5, 0x98, 0x78, 0xBE, 0x73, 0x0D,
        0x8C, 0x60, 0x55, 0x88, 0xD6, 0xA3, 0x80, 0x13,
        0x19, 0xDB, 0xF8, 0xCD, 0xA7, 0xDC, 0x28, 0x4C,
        0x09, 0xAF, 0xFE, 0x88, 0x77, 0xE1, 0x6E, 0x12,
        0x57, 0x5A, 0xA8, 0xC6, 0x38, 0xCF, 0xF5, 0x0D,
        0x42, 0x2C, 0x67, 0xB3, 0x22, 0x6F, 0x3D, 0x7D
};
static const uint8_t T14_CTR[] = { 0 };
static const uint8_t A14_CTR[] = { 0 };
#define A14_CTR_len 0

static const uint8_t K15_CTR[] = {
        0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,
        0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C
};
static const uint8_t IV15_CTR[] = {
        0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
        0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};
static const uint8_t P15_CTR[] = {
        0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96,
        0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A,
        0xAE, 0x2D, 0x8A, 0x57, 0x1E, 0x03, 0xAC, 0x9C,
        0x9E, 0xB7, 0x6F, 0xAC, 0x45, 0xAF, 0x8E, 0x51,
        0x30, 0xC8, 0x1C, 0x46, 0xA3, 0x5C, 0xE4, 0x11,
        0xE5, 0xFB, 0xC1, 0x19, 0x1A, 0x0A, 0x52, 0xEF,
        0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17,
        0xAD, 0x2B, 0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10
};

static const uint8_t C15_CTR[] = {
        0x87, 0x4D, 0x61, 0x91, 0xB6, 0x20, 0xE3, 0x26,
        0x1B, 0xEF, 0x68, 0x64, 0x99, 0x0D, 0xB6, 0xCE,
        0x98, 0x06, 0xF6, 0x6B, 0x79, 0x70, 0xFD, 0xFF,
        0x86, 0x17, 0x18, 0x7B, 0xB9, 0xFF, 0xFD, 0xFF,
        0x5A, 0xE4, 0xDF, 0x3E, 0xDB, 0xD5, 0xD3, 0x5E,
        0x5B, 0x4F, 0x09, 0x02, 0x0D, 0xB0, 0x3E, 0xAB,
        0x1E, 0x03, 0x1D, 0xDA, 0x2F, 0xBE, 0x03, 0xD1,
        0x79, 0x21, 0x70, 0xA0, 0xF3, 0x00, 0x9C, 0xEE
};

static const uint8_t T15_CTR[] = { 0 };
static const uint8_t A15_CTR[] = { 0 };
#define A15_CTR_len 0

#define bit_vector(N)                                                 \
        {K##N, (KBITS(K##N)), IV##N, sizeof(IV##N), A##N, A##N##_len, \
                        P##N, P##N##_len, C##N, T##N, sizeof(T##N)}

static const uint8_t K1_CTR_BIT[] = {
        0xd3, 0xc5, 0xd5, 0x92, 0x32, 0x7f, 0xb1, 0x1c,
        0x40, 0x35, 0xc6, 0x68, 0x0a, 0xf8, 0xc6, 0xd1

};
static const uint8_t IV1_CTR_BIT[] = {
        0x39, 0x8a, 0x59, 0xb4, 0xac, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* Last 3 bits (not to be ciphered) set to 1, since
 * the output buffer is set to all 0xff */
static const uint8_t P1_CTR_BIT[] = {
        0x98, 0x1b, 0xa6, 0x82, 0x4c, 0x1b, 0xfb, 0x1a,
        0xb4, 0x85, 0x47, 0x20, 0x29, 0xb7, 0x1d, 0x80,
        0x8c, 0xe3, 0x3e, 0x2c, 0xc3, 0xc0, 0xb5, 0xfc,
        0x1f, 0x3d, 0xe8, 0xa6, 0xdc, 0x66, 0xb1, 0xf7
};

static const uint8_t C1_CTR_BIT[] = {
        0xe9, 0xfe, 0xd8, 0xa6, 0x3d, 0x15, 0x53, 0x04,
        0xd7, 0x1d, 0xf2, 0x0b, 0xf3, 0xe8, 0x22, 0x14,
        0xb2, 0x0e, 0xd7, 0xda, 0xd2, 0xf2, 0x33, 0xdc,
        0x3c, 0x22, 0xd7, 0xbd, 0xee, 0xed, 0x8e, 0x7f
};

static const uint8_t T1_CTR_BIT[] = { 0 };
static const uint8_t A1_CTR_BIT[] = { 0 };
#define A1_CTR_BIT_len 0
#define P1_CTR_BIT_len 253

static const uint8_t K2_CTR_BIT[] = {
        0x2b, 0xd6, 0x45, 0x9f, 0x82, 0xc4, 0x40, 0xe0,
        0x95, 0x2c, 0x49, 0x10, 0x48, 0x05, 0xff, 0x48
};
static const uint8_t IV2_CTR_BIT[] = {
        0xc6, 0x75, 0xa6, 0x4b, 0x64, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* Last 2 bits (not to be ciphered) set to 1, since
 * the output buffer is set to all 0xff */
static const uint8_t P2_CTR_BIT[] = {
        0x7e, 0xc6, 0x12, 0x72, 0x74, 0x3b, 0xf1, 0x61,
        0x47, 0x26, 0x44, 0x6a, 0x6c, 0x38, 0xce, 0xd1,
        0x66, 0xf6, 0xca, 0x76, 0xeb, 0x54, 0x30, 0x04,
        0x42, 0x86, 0x34, 0x6c, 0xef, 0x13, 0x0f, 0x92,
        0x92, 0x2b, 0x03, 0x45, 0x0d, 0x3a, 0x99, 0x75,
        0xe5, 0xbd, 0x2e, 0xa0, 0xeb, 0x55, 0xad, 0x8e,
        0x1b, 0x19, 0x9e, 0x3e, 0xc4, 0x31, 0x60, 0x20,
        0xe9, 0xa1, 0xb2, 0x85, 0xe7, 0x62, 0x79, 0x53,
        0x59, 0xb7, 0xbd, 0xfd, 0x39, 0xbe, 0xf4, 0xb2,
        0x48, 0x45, 0x83, 0xd5, 0xaf, 0xe0, 0x82, 0xae,
        0xe6, 0x38, 0xbf, 0x5f, 0xd5, 0xa6, 0x06, 0x19,
        0x39, 0x01, 0xa0, 0x8f, 0x4a, 0xb4, 0x1a, 0xab,
        0x9b, 0x13, 0x48, 0x83
};

static const uint8_t C2_CTR_BIT[] = {
        0x59, 0x61, 0x60, 0x53, 0x53, 0xc6, 0x4b, 0xdc,
        0xa1, 0x5b, 0x19, 0x5e, 0x28, 0x85, 0x53, 0xa9,
        0x10, 0x63, 0x25, 0x06, 0xd6, 0x20, 0x0a, 0xa7,
        0x90, 0xc4, 0xc8, 0x06, 0xc9, 0x99, 0x04, 0xcf,
        0x24, 0x45, 0xcc, 0x50, 0xbb, 0x1c, 0xf1, 0x68,
        0xa4, 0x96, 0x73, 0x73, 0x4e, 0x08, 0x1b, 0x57,
        0xe3, 0x24, 0xce, 0x52, 0x59, 0xc0, 0xe7, 0x8d,
        0x4c, 0xd9, 0x7b, 0x87, 0x09, 0x76, 0x50, 0x3c,
        0x09, 0x43, 0xf2, 0xcb, 0x5a, 0xe8, 0xf0, 0x52,
        0xc7, 0xb7, 0xd3, 0x92, 0x23, 0x95, 0x87, 0xb8,
        0x95, 0x60, 0x86, 0xbc, 0xab, 0x18, 0x83, 0x60,
        0x42, 0xe2, 0xe6, 0xce, 0x42, 0x43, 0x2a, 0x17,
        0x10, 0x5c, 0x53, 0xd3
};

static const uint8_t T2_CTR_BIT[] = { 0 };
static const uint8_t A2_CTR_BIT[] = { 0 };
#define A2_CTR_BIT_len 0
#define P2_CTR_BIT_len 798

static const uint8_t K3_CTR_BIT[] = {
        0x0a, 0x8b, 0x6b, 0xd8, 0xd9, 0xb0, 0x8b, 0x08,
        0xd6, 0x4e, 0x32, 0xd1, 0x81, 0x77, 0x77, 0xfb
};

static const uint8_t IV3_CTR_BIT[] = {
        0x54, 0x4d, 0x49, 0xcd, 0x20, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* Last 2 bits (not to be ciphered) set to 1, since
 * the output buffer is set to all 0xff */
static const uint8_t P3_CTR_BIT[] = {
        0xfd, 0x40, 0xa4, 0x1d, 0x37, 0x0a, 0x1f, 0x65,
        0x74, 0x50, 0x95, 0x68, 0x7d, 0x47, 0xba, 0x1d,
        0x36, 0xd2, 0x34, 0x9e, 0x23, 0xf6, 0x44, 0x39,
        0x2c, 0x8e, 0xa9, 0xc4, 0x9d, 0x40, 0xc1, 0x32,
        0x71, 0xaf, 0xf2, 0x64, 0xd0, 0xf2, 0x4b
};

static const uint8_t C3_CTR_BIT[] = {
        0x75, 0x75, 0x0d, 0x37, 0xb4, 0xbb, 0xa2, 0xa4,
        0xde, 0xdb, 0x34, 0x23, 0x5b, 0xd6, 0x8c, 0x66,
        0x45, 0xac, 0xda, 0xac, 0xa4, 0x81, 0x38, 0xa3,
        0xb0, 0xc4, 0x71, 0xe2, 0xa7, 0x04, 0x1a, 0x57,
        0x64, 0x23, 0xd2, 0x92, 0x72, 0x87, 0xf3
};

static const uint8_t T3_CTR_BIT[] = { 0 };
static const uint8_t A3_CTR_BIT[] = { 0 };
#define A3_CTR_BIT_len 0
#define P3_CTR_BIT_len 310

static const uint8_t K4_CTR_BIT[] = {
        0xaa, 0x1f, 0x95, 0xae, 0xa5, 0x33, 0xbc, 0xb3,
        0x2e, 0xb6, 0x3b, 0xf5, 0x2d, 0x8f, 0x83, 0x1a
};

static const uint8_t IV4_CTR_BIT[] = {
        0x72, 0xd8, 0xc6, 0x71, 0x84, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* Last 2 bits (not to be ciphered) set to 1, since
 * the output buffer is set to all 0xff */
static const uint8_t P4_CTR_BIT[] = {
        0xfb, 0x1b, 0x96, 0xc5, 0xc8, 0xba, 0xdf, 0xb2,
        0xe8, 0xe8, 0xed, 0xfd, 0xe7, 0x8e, 0x57, 0xf2,
        0xad, 0x81, 0xe7, 0x41, 0x03, 0xfc, 0x43, 0x0a,
        0x53, 0x4d, 0xcc, 0x37, 0xaf, 0xce, 0xc7, 0x0e,
        0x15, 0x17, 0xbb, 0x06, 0xf2, 0x72, 0x19, 0xda,
        0xe4, 0x90, 0x22, 0xdd, 0xc4, 0x7a, 0x06, 0x8d,
        0xe4, 0xc9, 0x49, 0x6a, 0x95, 0x1a, 0x6b, 0x09,
        0xed, 0xbd, 0xc8, 0x64, 0xc7, 0xad, 0xbd, 0x74,
        0x0a, 0xc5, 0x0c, 0x02, 0x2f, 0x30, 0x82, 0xba,
        0xfd, 0x22, 0xd7, 0x81, 0x97, 0xc5, 0xd5, 0x08,
        0xb9, 0x77, 0xbc, 0xa1, 0x3f, 0x32, 0xe6, 0x52,
        0xe7, 0x4b, 0xa7, 0x28, 0x57, 0x60, 0x77, 0xce,
        0x62, 0x8c, 0x53, 0x5e, 0x87, 0xdc, 0x60, 0x77,
        0xba, 0x07, 0xd2, 0x90, 0x68, 0x59, 0x0c, 0x8c,
        0xb5, 0xf1, 0x08, 0x8e, 0x08, 0x2c, 0xfa, 0x0e,
        0xc9, 0x61, 0x30, 0x2d, 0x69, 0xcf, 0x3d, 0x47
};

static const uint8_t C4_CTR_BIT[] = {
        0xdf, 0xb4, 0x40, 0xac, 0xb3, 0x77, 0x35, 0x49,
        0xef, 0xc0, 0x46, 0x28, 0xae, 0xb8, 0xd8, 0x15,
        0x62, 0x75, 0x23, 0x0b, 0xdc, 0x69, 0x0d, 0x94,
        0xb0, 0x0d, 0x8d, 0x95, 0xf2, 0x8c, 0x4b, 0x56,
        0x30, 0x7f, 0x60, 0xf4, 0xca, 0x55, 0xeb, 0xa6,
        0x61, 0xeb, 0xba, 0x72, 0xac, 0x80, 0x8f, 0xa8,
        0xc4, 0x9e, 0x26, 0x78, 0x8e, 0xd0, 0x4a, 0x5d,
        0x60, 0x6c, 0xb4, 0x18, 0xde, 0x74, 0x87, 0x8b,
        0x9a, 0x22, 0xf8, 0xef, 0x29, 0x59, 0x0b, 0xc4,
        0xeb, 0x57, 0xc9, 0xfa, 0xf7, 0xc4, 0x15, 0x24,
        0xa8, 0x85, 0xb8, 0x97, 0x9c, 0x42, 0x3f, 0x2f,
        0x8f, 0x8e, 0x05, 0x92, 0xa9, 0x87, 0x92, 0x01,
        0xbe, 0x7f, 0xf9, 0x77, 0x7a, 0x16, 0x2a, 0xb8,
        0x10, 0xfe, 0xb3, 0x24, 0xba, 0x74, 0xc4, 0xc1,
        0x56, 0xe0, 0x4d, 0x39, 0x09, 0x72, 0x09, 0x65,
        0x3a, 0xc3, 0x3e, 0x5a, 0x5f, 0x2d, 0x88, 0x67
};

static const uint8_t T4_CTR_BIT[] = { 0 };
static const uint8_t A4_CTR_BIT[] = { 0 };
#define A4_CTR_BIT_len 0
#define P4_CTR_BIT_len 1022
static const uint8_t K5_CTR_BIT[] = {
        0x96, 0x18, 0xae, 0x46, 0x89, 0x1f, 0x86, 0x57,
        0x8e, 0xeb, 0xe9, 0x0e, 0xf7, 0xa1, 0x20, 0x2e
};

static const uint8_t IV5_CTR_BIT[] = {
        0xc6, 0x75, 0xa6, 0x4b, 0x64, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* Last 3 bits (not to be ciphered) set to 1, since
 * the output buffer is set to all 0xff */
static const uint8_t P5_CTR_BIT[] = {
        0x8d, 0xaa, 0x17, 0xb1, 0xae, 0x05, 0x05, 0x29,
        0xc6, 0x82, 0x7f, 0x28, 0xc0, 0xef, 0x6a, 0x12,
        0x42, 0xe9, 0x3f, 0x8b, 0x31, 0x4f, 0xb1, 0x8a,
        0x77, 0xf7, 0x90, 0xae, 0x04, 0x9f, 0xed, 0xd6,
        0x12, 0x26, 0x7f, 0xec, 0xae, 0xfc, 0x45, 0x01,
        0x74, 0xd7, 0x6d, 0x9f, 0x9a, 0xa7, 0x75, 0x5a,
        0x30, 0xcd, 0x90, 0xa9, 0xa5, 0x87, 0x4b, 0xf4,
        0x8e, 0xaf, 0x70, 0xee, 0xa3, 0xa6, 0x2a, 0x25,
        0x0a, 0x8b, 0x6b, 0xd8, 0xd9, 0xb0, 0x8b, 0x08,
        0xd6, 0x4e, 0x32, 0xd1, 0x81, 0x77, 0x77, 0xfb,
        0x54, 0x4d, 0x49, 0xcd, 0x49, 0x72, 0x0e, 0x21,
        0x9d, 0xbf, 0x8b, 0xbe, 0xd3, 0x39, 0x04, 0xe1,
        0xfd, 0x40, 0xa4, 0x1d, 0x37, 0x0a, 0x1f, 0x65,
        0x74, 0x50, 0x95, 0x68, 0x7d, 0x47, 0xba, 0x1d,
        0x36, 0xd2, 0x34, 0x9e, 0x23, 0xf6, 0x44, 0x39,
        0x2c, 0x8e, 0xa9, 0xc4, 0x9d, 0x40, 0xc1, 0x32,
        0x71, 0xaf, 0xf2, 0x64, 0xd0, 0xf2, 0x48, 0x41,
        0xd6, 0x46, 0x5f, 0x09, 0x96, 0xff, 0x84, 0xe6,
        0x5f, 0xc5, 0x17, 0xc5, 0x3e, 0xfc, 0x33, 0x63,
        0xc3, 0x84, 0x92, 0xaf
};

static const uint8_t C5_CTR_BIT[] = {
        0x91, 0x9c, 0x8c, 0x33, 0xd6, 0x67, 0x89, 0x70,
        0x3d, 0x05, 0xa0, 0xd7, 0xce, 0x82, 0xa2, 0xae,
        0xac, 0x4e, 0xe7, 0x6c, 0x0f, 0x4d, 0xa0, 0x50,
        0x33, 0x5e, 0x8a, 0x84, 0xe7, 0x89, 0x7b, 0xa5,
        0xdf, 0x2f, 0x36, 0xbd, 0x51, 0x3e, 0x3d, 0x0c,
        0x85, 0x78, 0xc7, 0xa0, 0xfc, 0xf0, 0x43, 0xe0,
        0x3a, 0xa3, 0xa3, 0x9f, 0xba, 0xad, 0x7d, 0x15,
        0xbe, 0x07, 0x4f, 0xaa, 0x5d, 0x90, 0x29, 0xf7,
        0x1f, 0xb4, 0x57, 0xb6, 0x47, 0x83, 0x47, 0x14,
        0xb0, 0xe1, 0x8f, 0x11, 0x7f, 0xca, 0x10, 0x67,
        0x79, 0x45, 0x09, 0x6c, 0x8c, 0x5f, 0x32, 0x6b,
        0xa8, 0xd6, 0x09, 0x5e, 0xb2, 0x9c, 0x3e, 0x36,
        0xcf, 0x24, 0x5d, 0x16, 0x22, 0xaa, 0xfe, 0x92,
        0x1f, 0x75, 0x66, 0xc4, 0xf5, 0xd6, 0x44, 0xf2,
        0xf1, 0xfc, 0x0e, 0xc6, 0x84, 0xdd, 0xb2, 0x13,
        0x49, 0x74, 0x76, 0x22, 0xe2, 0x09, 0x29, 0x5d,
        0x27, 0xff, 0x3f, 0x95, 0x62, 0x33, 0x71, 0xd4,
        0x9b, 0x14, 0x7c, 0x0a, 0xf4, 0x86, 0x17, 0x1f,
        0x22, 0xcd, 0x04, 0xb1, 0xcb, 0xeb, 0x26, 0x58,
        0x22, 0x3e, 0x69, 0x3f
};

static const uint8_t T5_CTR_BIT[] = { 0 };
static const uint8_t A5_CTR_BIT[] = { 0 };
#define A5_CTR_BIT_len 0
#define P5_CTR_BIT_len 1245

static const uint8_t K6_CTR_BIT[] = {
        0x54, 0xf4, 0xe2, 0xe0, 0x4c, 0x83, 0x78, 0x6e,
        0xec, 0x8f, 0xb5, 0xab, 0xe8, 0xe3, 0x65, 0x66
};

static const uint8_t IV6_CTR_BIT[] = {
        0xac, 0xa4, 0xf5, 0x0f, 0x58, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const uint8_t P6_CTR_BIT[] = {
        0x40, 0x98, 0x1b, 0xa6, 0x82, 0x4c, 0x1b, 0xfb,
        0x42, 0x86, 0xb2, 0x99, 0x78, 0x3d, 0xaf, 0x44,
        0x2c, 0x09, 0x9f, 0x7a, 0xb0, 0xf5, 0x8d, 0x5c,
        0x8e, 0x46, 0xb1, 0x04, 0xf0, 0x8f, 0x01, 0xb4,
        0x1a, 0xb4, 0x85, 0x47, 0x20, 0x29, 0xb7, 0x1d,
        0x36, 0xbd, 0x1a, 0x3d, 0x90, 0xdc, 0x3a, 0x41,
        0xb4, 0x6d, 0x51, 0x67, 0x2a, 0xc4, 0xc9, 0x66,
        0x3a, 0x2b, 0xe0, 0x63, 0xda, 0x4b, 0xc8, 0xd2,
        0x80, 0x8c, 0xe3, 0x3e, 0x2c, 0xcc, 0xbf, 0xc6,
        0x34, 0xe1, 0xb2, 0x59, 0x06, 0x08, 0x76, 0xa0,
        0xfb, 0xb5, 0xa4, 0x37, 0xeb, 0xcc, 0x8d, 0x31,
        0xc1, 0x9e, 0x44, 0x54, 0x31, 0x87, 0x45, 0xe3,
        0xfa, 0x16, 0xbb, 0x11, 0xad, 0xae, 0x24, 0x88,
        0x79, 0xfe, 0x52, 0xdb, 0x25, 0x43, 0xe5, 0x3c,
        0xf4, 0x45, 0xd3, 0xd8, 0x28, 0xce, 0x0b, 0xf5,
        0xc5, 0x60, 0x59, 0x3d, 0x97, 0x27, 0x8a, 0x59,
        0x76, 0x2d, 0xd0, 0xc2, 0xc9, 0xcd, 0x68, 0xd4,
        0x49, 0x6a, 0x79, 0x25, 0x08, 0x61, 0x40, 0x14,
        0xb1, 0x3b, 0x6a, 0xa5, 0x11, 0x28, 0xc1, 0x8c,
        0xd6, 0xa9, 0x0b, 0x87, 0x97, 0x8c, 0x2f, 0xf1,
        0xca, 0xbe, 0x7d, 0x9f, 0x89, 0x8a, 0x41, 0x1b,
        0xfd, 0xb8, 0x4f, 0x68, 0xf6, 0x72, 0x7b, 0x14,
        0x99, 0xcd, 0xd3, 0x0d, 0xf0, 0x44, 0x3a, 0xb4,
        0xa6, 0x66, 0x53, 0x33, 0x0b, 0xcb, 0xa1, 0x10,
        0x5e, 0x4c, 0xec, 0x03, 0x4c, 0x73, 0xe6, 0x05,
        0xb4, 0x31, 0x0e, 0xaa, 0xad, 0xcf, 0xd5, 0xb0,
        0xca, 0x27, 0xff, 0xd8, 0x9d, 0x14, 0x4d, 0xf4,
        0x79, 0x27, 0x59, 0x42, 0x7c, 0x9c, 0xc1, 0xf8,
        0xcd, 0x8c, 0x87, 0x20, 0x23, 0x64, 0xb8, 0xa6,
        0x87, 0x95, 0x4c, 0xb0, 0x5a, 0x8d, 0x4e, 0x2d,
        0x99, 0xe7, 0x3d, 0xb1, 0x60, 0xde, 0xb1, 0x80,
        0xad, 0x08, 0x41, 0xe9, 0x67, 0x41, 0xa5, 0xd5,
        0x9f, 0xe4, 0x18, 0x9f, 0x15, 0x42, 0x00, 0x26,
        0xfe, 0x4c, 0xd1, 0x21, 0x04, 0x93, 0x2f, 0xb3,
        0x8f, 0x73, 0x53, 0x40, 0x43, 0x8a, 0xaf, 0x7e,
        0xca, 0x6f, 0xd5, 0xcf, 0xd3, 0xa1, 0x95, 0xce,
        0x5a, 0xbe, 0x65, 0x27, 0x2a, 0xf6, 0x07, 0xad,
        0xa1, 0xbe, 0x65, 0xa6, 0xb4, 0xc9, 0xc0, 0x69,
        0x32, 0x34, 0x09, 0x2c, 0x4d, 0x01, 0x8f, 0x17,
        0x56, 0xc6, 0xdb, 0x9d, 0xc8, 0xa6, 0xd8, 0x0b,
        0x88, 0x81, 0x38, 0x61, 0x6b, 0x68, 0x12, 0x62,
        0xf9, 0x54, 0xd0, 0xe7, 0x71, 0x17, 0x48, 0x78,
        0x0d, 0x92, 0x29, 0x1d, 0x86, 0x29, 0x99, 0x72,
        0xdb, 0x74, 0x1c, 0xfa, 0x4f, 0x37, 0xb8, 0xb5,
        0x6c, 0xdb, 0x18, 0xa7, 0xca, 0x82, 0x18, 0xe8,
        0x6e, 0x4b, 0x4b, 0x71, 0x6a, 0x4d, 0x04, 0x37,
        0x1f, 0xbe, 0xc2, 0x62, 0xfc, 0x5a, 0xd0, 0xb3,
        0x81, 0x9b, 0x18, 0x7b, 0x97, 0xe5, 0x5b, 0x1a,
        0x4d, 0x7c, 0x19, 0xee, 0x24, 0xc8, 0xb4, 0xd7,
        0x72, 0x3c, 0xfe, 0xdf, 0x04, 0x5b, 0x8a, 0xca,
        0xe4, 0x86, 0x95, 0x17, 0xd8, 0x0e, 0x50, 0x61,
        0x5d, 0x90, 0x35, 0xd5, 0xd9, 0xc5, 0xa4, 0x0a,
        0xf6, 0x02, 0x28, 0x0b, 0x54, 0x25, 0x97, 0xb0,
        0xcb, 0x18, 0x61, 0x9e, 0xeb, 0x35, 0x92, 0x57,
        0x59, 0xd1, 0x95, 0xe1, 0x00, 0xe8, 0xe4, 0xaa,
        0x0c, 0x38, 0xa3, 0xc2, 0xab, 0xe0, 0xf3, 0xd8,
        0xff, 0x04, 0xf3, 0xc3, 0x3c, 0x29, 0x50, 0x69,
        0xc2, 0x36, 0x94, 0xb5, 0xbb, 0xea, 0xcd, 0xd5,
        0x42, 0xe2, 0x8e, 0x8a, 0x94, 0xed, 0xb9, 0x11,
        0x9f, 0x41, 0x2d, 0x05, 0x4b, 0xe1, 0xfa, 0x72,
        0x00, 0xb0, 0x97
};

static const uint8_t C6_CTR_BIT[] = {
        0x5c, 0xb7, 0x2c, 0x6e, 0xdc, 0x87, 0x8f, 0x15,
        0x66, 0xe1, 0x02, 0x53, 0xaf, 0xc3, 0x64, 0xc9,
        0xfa, 0x54, 0x0d, 0x91, 0x4d, 0xb9, 0x4c, 0xbe,
        0xe2, 0x75, 0xd0, 0x91, 0x7c, 0xa6, 0xaf, 0x0d,
        0x77, 0xac, 0xb4, 0xef, 0x3b, 0xbe, 0x1a, 0x72,
        0x2b, 0x2e, 0xf5, 0xbd, 0x1d, 0x4b, 0x8e, 0x2a,
        0xa5, 0x02, 0x4e, 0xc1, 0x38, 0x8a, 0x20, 0x1e,
        0x7b, 0xce, 0x79, 0x20, 0xae, 0xc6, 0x15, 0x89,
        0x5f, 0x76, 0x3a, 0x55, 0x64, 0xdc, 0xc4, 0xc4,
        0x82, 0xa2, 0xee, 0x1d, 0x8b, 0xfe, 0xcc, 0x44,
        0x98, 0xec, 0xa8, 0x3f, 0xbb, 0x75, 0xf9, 0xab,
        0x53, 0x0e, 0x0d, 0xaf, 0xbe, 0xde, 0x2f, 0xa5,
        0x89, 0x5b, 0x82, 0x99, 0x1b, 0x62, 0x77, 0xc5,
        0x29, 0xe0, 0xf2, 0x52, 0x9d, 0x7f, 0x79, 0x60,
        0x6b, 0xe9, 0x67, 0x06, 0x29, 0x6d, 0xed, 0xfa,
        0x9d, 0x74, 0x12, 0xb6, 0x16, 0x95, 0x8c, 0xb5,
        0x63, 0xc6, 0x78, 0xc0, 0x28, 0x25, 0xc3, 0x0d,
        0x0a, 0xee, 0x77, 0xc4, 0xc1, 0x46, 0xd2, 0x76,
        0x54, 0x12, 0x42, 0x1a, 0x80, 0x8d, 0x13, 0xce,
        0xc8, 0x19, 0x69, 0x4c, 0x75, 0xad, 0x57, 0x2e,
        0x9b, 0x97, 0x3d, 0x94, 0x8b, 0x81, 0xa9, 0x33,
        0x7c, 0x3b, 0x2a, 0x17, 0x19, 0x2e, 0x22, 0xc2,
        0x06, 0x9f, 0x7e, 0xd1, 0x16, 0x2a, 0xf4, 0x4c,
        0xde, 0xa8, 0x17, 0x60, 0x36, 0x65, 0xe8, 0x07,
        0xce, 0x40, 0xc8, 0xe0, 0xdd, 0x9d, 0x63, 0x94,
        0xdc, 0x6e, 0x31, 0x15, 0x3f, 0xe1, 0x95, 0x5c,
        0x47, 0xaf, 0xb5, 0x1f, 0x26, 0x17, 0xee, 0x0c,
        0x5e, 0x3b, 0x8e, 0xf1, 0xad, 0x75, 0x74, 0xed,
        0x34, 0x3e, 0xdc, 0x27, 0x43, 0xcc, 0x94, 0xc9,
        0x90, 0xe1, 0xf1, 0xfd, 0x26, 0x42, 0x53, 0xc1,
        0x78, 0xde, 0xa7, 0x39, 0xc0, 0xbe, 0xfe, 0xeb,
        0xcd, 0x9f, 0x9b, 0x76, 0xd4, 0x9c, 0x10, 0x15,
        0xc9, 0xfe, 0xcf, 0x50, 0xe5, 0x3b, 0x8b, 0x52,
        0x04, 0xdb, 0xcd, 0x3e, 0xed, 0x86, 0x38, 0x55,
        0xda, 0xbc, 0xdc, 0xc9, 0x4b, 0x31, 0xe3, 0x18,
        0x02, 0x15, 0x68, 0x85, 0x5c, 0x8b, 0x9e, 0x52,
        0xa9, 0x81, 0x95, 0x7a, 0x11, 0x28, 0x27, 0xf9,
        0x78, 0xba, 0x96, 0x0f, 0x14, 0x47, 0x91, 0x1b,
        0x31, 0x7b, 0x55, 0x11, 0xfb, 0xcc, 0x7f, 0xb1,
        0x3a, 0xc1, 0x53, 0xdb, 0x74, 0x25, 0x11, 0x17,
        0xe4, 0x86, 0x1e, 0xb9, 0xe8, 0x3b, 0xff, 0xff,
        0xc4, 0xeb, 0x77, 0x55, 0x57, 0x90, 0x38, 0xe5,
        0x79, 0x24, 0xb1, 0xf7, 0x8b, 0x3e, 0x1a, 0xd9,
        0x0b, 0xab, 0x2a, 0x07, 0x87, 0x1b, 0x72, 0xdb,
        0x5e, 0xef, 0x96, 0xc3, 0x34, 0x04, 0x49, 0x66,
        0xdb, 0x0c, 0x37, 0xca, 0xfd, 0x1a, 0x89, 0xe5,
        0x64, 0x6a, 0x35, 0x80, 0xeb, 0x64, 0x65, 0xf1,
        0x21, 0xdc, 0xe9, 0xcb, 0x88, 0xd8, 0x5b, 0x96,
        0xcf, 0x23, 0xcc, 0xcc, 0xd4, 0x28, 0x07, 0x67,
        0xbe, 0xe8, 0xee, 0xb2, 0x3d, 0x86, 0x52, 0x46,
        0x1d, 0xb6, 0x49, 0x31, 0x03, 0x00, 0x3b, 0xaf,
        0x89, 0xf5, 0xe1, 0x82, 0x61, 0xea, 0x43, 0xc8,
        0x4a, 0x92, 0xeb, 0xff, 0xff, 0xe4, 0x90, 0x9d,
        0xc4, 0x6c, 0x51, 0x92, 0xf8, 0x25, 0xf7, 0x70,
        0x60, 0x0b, 0x96, 0x02, 0xc5, 0x57, 0xb5, 0xf8,
        0xb4, 0x31, 0xa7, 0x9d, 0x45, 0x97, 0x7d, 0xd9,
        0xc4, 0x1b, 0x86, 0x3d, 0xa9, 0xe1, 0x42, 0xe9,
        0x00, 0x20, 0xcf, 0xd0, 0x74, 0xd6, 0x92, 0x7b,
        0x7a, 0xb3, 0xb6, 0x72, 0x5d, 0x1a, 0x6f, 0x3f,
        0x98, 0xb9, 0xc9, 0xda, 0xa8, 0x98, 0x2a, 0xff,
        0x06, 0x78, 0x2f
};

static const uint8_t T6_CTR_BIT[] = { 0 };
static const uint8_t A6_CTR_BIT[] = { 0 };
#define A6_CTR_BIT_len 0
#define P6_CTR_BIT_len 3861

#define bit_vector(N)                                                 \
        {K##N, (KBITS(K##N)), IV##N, sizeof(IV##N), A##N, A##N##_len, \
                        P##N, P##N##_len, C##N, T##N, sizeof(T##N)}

#define MAX_JOBS 128

enum key_size {
        BITS_128 = 16,
        BITS_192 = 24,
        BITS_256 = 32,
};

typedef enum {
        IMB_CIPHER_CBC = 1,
        IMB_CIPHER_CNTR,
        IMB_CIPHER_NULL,
        IMB_CIPHER_DOCSIS_SEC_BPI,
        IMB_CIPHER_GCM,
        IMB_CIPHER_CUSTOM,
        IMB_CIPHER_DES,
        IMB_CIPHER_DOCSIS_DES,
        IMB_CIPHER_CCM,
        IMB_CIPHER_DES3,
        IMB_CIPHER_PON_AES_CNTR,
        IMB_CIPHER_ECB,
        IMB_CIPHER_CNTR_BITLEN,       /* 128-EEA2/NEA2 (3GPP) */
        IMB_CIPHER_ZUC_EEA3,          /* 128-EEA3/NEA3 (3GPP) */
        IMB_CIPHER_SNOW3G_UEA2_BITLEN,/* 128-UEA2 (3GPP) */
        IMB_CIPHER_KASUMI_UEA1_BITLEN /* 128-UEA1 (3GPP) */
} job_cipher_mode;

typedef enum {
        IMB_DIR_ENCRYPT = 1,
        IMB_DIR_DECRYPT
} job_cipher_direction;

typedef enum {
        STS_BEING_PROCESSED = 0,
        STS_COMPLETED_AES =   1,
        STS_COMPLETED_HMAC =  2,
        STS_COMPLETED =       3, /* COMPLETED_AES | COMPLETED_HMAC */
        STS_INVALID_ARGS =    4,
        STS_INTERNAL_ERROR,
        STS_ERROR
} job_sts;

typedef enum {
        IMB_AUTH_HMAC_SHA_1 = 1,    /* HMAC-SHA1 */
        IMB_AUTH_HMAC_SHA_224,      /* HMAC-SHA224 */
        IMB_AUTH_HMAC_SHA_256,      /* HMAC-SHA256 */
        IMB_AUTH_HMAC_SHA_384,      /* HMAC-SHA384 */
        IMB_AUTH_HMAC_SHA_512,      /* HMAC-SHA512 */
        IMB_AUTH_AES_XCBC,
        IMB_AUTH_MD5,               /* HMAC-MD5 */
        IMB_AUTH_NULL,
        IMB_AUTH_AES_GMAC,
        IMB_AUTH_CUSTOM,
        IMB_AUTH_AES_CCM,            /* AES128-CCM */
        IMB_AUTH_AES_CMAC,           /* AES128-CMAC */
        IMB_AUTH_SHA_1,              /* SHA1 */
        IMB_AUTH_SHA_224,            /* SHA224 */
        IMB_AUTH_SHA_256,            /* SHA256 */
        IMB_AUTH_SHA_384,            /* SHA384 */
        IMB_AUTH_SHA_512,            /* SHA512 */
        IMB_AUTH_AES_CMAC_BITLEN,    /* 128-EIA2/NIA2 (3GPP) */
        IMB_AUTH_PON_CRC_BIP,
        IMB_AUTH_ZUC_EIA3_BITLEN,    /* 128-EIA3/NIA3 (3GPP) */
        IMB_AUTH_DOCSIS_CRC32,       /* with DOCSIS_SEC_BPI only */
        IMB_AUTH_SNOW3G_UIA2_BITLEN, /* 128-UIA2 (3GPP) */
        IMB_AUTH_KASUMI_UIA1,        /* 128-UIA1 (3GPP) */
} job_hash_alg;

typedef enum {
        IMB_ORDER_CIPHER_HASH = 1,
        IMB_ORDER_HASH_CIPHER
} job_chain_order;

typedef struct {
        uint64_t low;
        uint64_t high;
} imb_uint128_t;

struct mb_job {
        const void *enc_keys;
        const void *dec_keys;
        uint64_t key_len_in_bytes;
        const uint8_t *src;
        uint8_t *dst;
        union {
                uint64_t cipher_start_src_offset_in_bytes;
                uint64_t cipher_start_src_offset_in_bits;
        };
        union {
                uint64_t msg_len_to_cipher_in_bytes;
                uint64_t msg_len_to_cipher_in_bits;
        };
        const uint8_t *iv; /* Initialization Vector (IV) */
        uint64_t iv_len_in_bytes; /* IV length in bytes. */
        job_sts status;
        job_cipher_mode cipher_mode;
        job_cipher_direction cipher_direction;
        job_hash_alg hash_alg; /* IMB_AUTH_SHA_1 or others... */
        job_chain_order chain_order;
};

struct mb_mgr {
        int              earliest_job; /* byte offset, -1 if none */
        int              next_job;     /* byte offset */
        struct mb_job    jobs[MAX_JOBS];
};

extern void aes_cntr_128_submit_vaes_avx512(struct mb_job *job);
extern void aes_cntr_192_submit_vaes_avx512(struct mb_job *job);
extern void aes_cntr_256_submit_vaes_avx512(struct mb_job *job);
extern void aes_cntr_bit_128_submit_vaes_avx512(struct mb_job *job);
extern void aes_cntr_bit_192_submit_vaes_avx512(struct mb_job *job);
extern void aes_cntr_bit_256_submit_vaes_avx512(struct mb_job *job);
extern void aes_keyexp_128_avx512(const void *key, void *enc_exp_keys, void *dec_exp_keys);
extern void aes_keyexp_192_avx512(const void *key, void *enc_exp_keys, void *dec_exp_keys);
extern void aes_keyexp_256_avx512(const void *key, void *enc_exp_keys, void *dec_exp_keys);

struct gcm_ctr_vector {
        const uint8_t* K;          // AES Key
        enum key_size  Klen;       // length of key in bits
        const uint8_t* IV;         // initial value used by GCM
        uint64_t       IVlen;      // length of IV in bytes
        const uint8_t* A;          // additional authenticated data
        uint64_t       Alen;       // length of AAD in bytes
        const uint8_t* P;          // Plain text
        uint64_t       Plen;       // length of our plaintext
        //outputs of encryption
        const uint8_t* C;          // same length as PT
        const uint8_t* T;          // Authenication tag
        uint8_t        Tlen;       // AT length can be 0 to 128bits
};

static const struct gcm_ctr_vector ctr_vectors[] = {
        vector(1_CTR),
        vector(2_CTR),
	vector(3_CTR),
        vector(4_CTR),
        vector(5_CTR),
        vector(6_CTR),
        vector(7_CTR),
        vector(8_CTR),
        vector(9_CTR),
        vector(10_CTR),
        vector(11_CTR),
        vector(12_CTR),
        vector(13_CTR),
        vector(14_CTR),
        vector(15_CTR)
};

static const struct gcm_ctr_vector ctr_bit_vectors[] = {
        bit_vector(1_CTR_BIT),
        bit_vector(2_CTR_BIT),
	bit_vector(3_CTR_BIT),
        bit_vector(4_CTR_BIT),
        bit_vector(5_CTR_BIT),
        bit_vector(6_CTR_BIT)
};

#define STS_BEING_PROCESSED     0
#define STS_COMPLETED_AES       1
#define STS_COMPLETED_HMAC      2
#define STS_COMPLETED           3
#define STS_INVALID_ARGS        4

#define DECLARE_ALIGNED(decl, alignval) \
        decl __attribute__((aligned(alignval)))

#define BYTE_ROUND_UP(x) ((x + 7) / 8)

#define DIM(x) (sizeof(x) / sizeof(x[0]))

static struct mb_job *vaes_submit_cntr_avx512(struct mb_job *job)
{
        if (16 == job->key_len_in_bytes)
                aes_cntr_128_submit_vaes_avx512(job);
        else if (24 == job->key_len_in_bytes)
                aes_cntr_192_submit_vaes_avx512(job);
        else /* assume 32 bytes */
                aes_cntr_256_submit_vaes_avx512(job);
        job->status |= STS_COMPLETED_AES;
        return job;
}

static struct mb_job *vaes_submit_cntr_bit_avx512(struct mb_job *job)
{
        if (16 == job->key_len_in_bytes)
                aes_cntr_bit_128_submit_vaes_avx512(job);
        else if (24 == job->key_len_in_bytes)
                aes_cntr_bit_192_submit_vaes_avx512(job);
        else /* assume 32 bytes */
                aes_cntr_bit_256_submit_vaes_avx512(job);

        job->status |= STS_COMPLETED_AES;
        return job;
}

struct mb_job *submit_job_hash(struct mb_job *job)
{
	job->status |= STS_COMPLETED_HMAC;
	return job;
}

struct mb_job *submit_job_aes_enc(struct mb_job *job)
{
	if (IMB_CIPHER_CNTR == job->cipher_mode)
                return vaes_submit_cntr_avx512(job);
        else if (IMB_CIPHER_CNTR_BITLEN == job->cipher_mode)
                return vaes_submit_cntr_bit_avx512(job);
        else {
                job->status |= STS_COMPLETED_AES;
                return job;
        }
}

struct mb_job *submit_job_aes_dec(struct mb_job *job)
{
        if (IMB_CIPHER_CNTR == job->cipher_mode)
                return vaes_submit_cntr_avx512(job);
        else if (IMB_CIPHER_CNTR_BITLEN == job->cipher_mode)
                return vaes_submit_cntr_bit_avx512(job);
        else {
                job->status |= STS_COMPLETED_AES;
                return job;
        }
}

struct mb_job *submit_job_aes(struct mb_job *job)
{
	if (job->cipher_direction == IMB_DIR_ENCRYPT)
                job = submit_job_aes_enc(job);
        else
                job = submit_job_aes_dec(job);

        return job;
}

struct mb_job *resubmit_job(struct mb_job *job)
{
        while (job != NULL && job->status < STS_COMPLETED) {
                if (job->status == STS_COMPLETED_HMAC)
                        job = submit_job_aes(job);
                else {
                        job->status |= STS_COMPLETED_HMAC;
                        return job;
                }
        }
        return job;
}

struct mb_job *submit_new_job(struct mb_job *job)
{
        if (job->chain_order == IMB_ORDER_CIPHER_HASH)
                job = submit_job_aes(job);
        else
                job->status |= STS_COMPLETED_HMAC;

        job = resubmit_job(job);
        return job;
}

int is_job_invalid(const struct mb_job *job)
{
	if (job->src == NULL) {
		printf("cipher_mode:%d\n", job->cipher_mode);
		return 1;
	}
	if (job->dst == NULL) {
		printf("cipher_mode:%d\n", job->cipher_mode);
		return 1;
	}
	if (job->iv == NULL) {
		printf("cipher_mode:%d\n", job->cipher_mode);
		return 1;
	}
	if (job->enc_keys == NULL) {
		printf("cipher_mode:%d\n", job->cipher_mode);
		return 1;
	}
	if (job->key_len_in_bytes != UINT64_C(16) &&
	    job->key_len_in_bytes != UINT64_C(24) &&
	    job->key_len_in_bytes != UINT64_C(32)) {
		printf("cipher_mode:%d\n", job->cipher_mode);
			return 1;
	}
	if (job->iv_len_in_bytes != UINT64_C(16) &&
	    job->iv_len_in_bytes != UINT64_C(12)) {
		printf("cipher_mode:%d\n", job->cipher_mode);
			return 1;
	}
	if (job->msg_len_to_cipher_in_bytes == 0) {
		printf("cipher_mode:%d\n", job->cipher_mode);
		return 1;
	}
	return 0;
}

struct mb_job *jobs(struct mb_mgr *state, const int offset)
{
        char *cp = (char *)state->jobs;

        return (struct mb_job *)(cp + offset);
}

void adv_jobs(int *ptr)
{
        *ptr += sizeof(struct mb_job);
        if (*ptr >= (int) (MAX_JOBS * sizeof(struct mb_job)))
                *ptr = 0;
}

struct mb_job *flush_job_hash(struct mb_job *job)
{
        if (!(job->status & STS_COMPLETED_HMAC)) {
                job->status |= STS_COMPLETED_HMAC;
                return job;
        }
        return NULL;
}

void complete_job(struct mb_job *job)
{
        while (job->status < STS_COMPLETED) {
                struct mb_job *tmp = flush_job_hash(job);
                (void) resubmit_job(tmp);
        }
}

struct mb_job *submit_job_and_check(struct mb_mgr *state, const int run_check)
{
        struct mb_job *job = NULL;

        job = jobs(state, state->next_job);
        if (run_check) {
                if (is_job_invalid(job)) {
                        job->status = STS_INVALID_ARGS;
                } else {
                        job->status = STS_BEING_PROCESSED;
                        job = submit_new_job(job);
                }
        } else {
                job->status = STS_BEING_PROCESSED;
                job = submit_new_job(job);
        }
        if (state->earliest_job < 0) {
                /* state was previously empty */
                if (job == NULL)
                        state->earliest_job = state->next_job;
                adv_jobs(&state->next_job);
                goto exit;
        }
        adv_jobs(&state->next_job);
        if (state->earliest_job == state->next_job) {
                job = jobs(state, state->earliest_job);
                complete_job(job);
                adv_jobs(&state->earliest_job);
                goto exit;
        }
        job = jobs(state, state->earliest_job);
        if (job->status < STS_COMPLETED) {
                job = NULL;
                goto exit;
        }

        adv_jobs(&state->earliest_job);
exit:
        return job;
}

struct mb_job *submit_job(struct mb_mgr *state)
{
        return submit_job_and_check(state, 1);
}

struct mb_job *get_next_job(struct mb_mgr *state)
{
        return jobs(state, state->next_job);
}

struct mb_job *flush_job(struct mb_mgr *state)
{
        struct mb_job *job;
        DECLARE_ALIGNED(imb_uint128_t xmm_save[10], 16);

        if (state->earliest_job < 0)
                return NULL; /* empty */

	job = jobs(state, state->earliest_job);
        complete_job(job);

        adv_jobs(&state->earliest_job);

        if (state->earliest_job == state->next_job)
                state->earliest_job = -1; /* becomes empty */

        return job;
}

void hexdump(FILE *fp, const char *msg, const void *p, size_t len)
{
        unsigned int i, out, ofs;
        const unsigned char *data = p;

        fprintf(fp, "%s\n", msg);

        ofs = 0;
        while (ofs < len) {
                char line[120];

                out = snprintf(line, sizeof(line), "%08x:", ofs);
                for (i = 0; ((ofs + i) < len) && (i < 16); i++)
                        out += snprintf(line + out, sizeof(line) - out,
                                        " %02x", (data[ofs + i] & 0xff));
                for (; i <= 16; i++)
                        out += snprintf(line + out, sizeof(line) - out, " | ");
                for (i = 0; (ofs < len) && (i < 16); i++, ofs++) {
                        unsigned char c = data[ofs];

                        if ((c < ' ') || (c > '~'))
                                c = '.';
                        out += snprintf(line + out,
                                        sizeof(line) - out, "%c", c);
                }
                fprintf(fp, "%s\n", line);
        }
}

static int test_ctr(struct mb_mgr *mb_mgr, const void *expkey, unsigned key_len,
	            const void *iv, unsigned iv_len, const uint8_t *in_text,
	            const uint8_t *out_text, unsigned text_len, int dir,
	            int order, const job_cipher_mode alg)
{
        uint32_t text_byte_len;
        struct mb_job *job;
        uint8_t padding[16];
        uint8_t *target;
        int ret = -1;

        if (alg == IMB_CIPHER_CNTR)
                text_byte_len = text_len;
        else
                text_byte_len = BYTE_ROUND_UP(text_len);

        target = malloc(text_byte_len + (sizeof(padding) * 2));
        if (target == NULL) {
                fprintf(stderr, "Can't allocate buffer memory\n");
                goto end;
        }

        memset(target, -1, text_byte_len + (sizeof(padding) * 2));
        memset(padding, -1, sizeof(padding));

        job = get_next_job(mb_mgr);
        job->cipher_direction = dir;
        job->chain_order = order;
        job->dst = target + 16;
        job->src = in_text;
        job->cipher_mode = alg;
        job->enc_keys = expkey;
        job->dec_keys = expkey;
        job->key_len_in_bytes = key_len;
        job->iv = iv;
        job->iv_len_in_bytes = iv_len;
        job->cipher_start_src_offset_in_bytes = 0;
        if (alg == IMB_CIPHER_CNTR)
                job->msg_len_to_cipher_in_bytes = text_byte_len;
        else
                job->msg_len_to_cipher_in_bits = text_len;

        job->hash_alg = IMB_AUTH_NULL;

        job = submit_job(mb_mgr);
        if (!job) {
                printf("%d Unexpected null return from submit_job\n", __LINE__);
                goto end;
        }
        if (job->status != STS_COMPLETED) {
                printf("%d Error status:%d", __LINE__, job->status);
                goto end;
        }
        job = flush_job(mb_mgr);
        if (job) {
                printf("%u Unexpected return from flush_job\n", __LINE__);
                goto end;
	}
	if (memcmp(out_text, target + 16, text_byte_len)) {
                printf("mismatched\n");
                hexdump(stderr, "Target", target, text_byte_len + 32);
                hexdump(stderr, "Expected", out_text, text_byte_len);
                goto end;
        }
        if (memcmp(padding, target, sizeof(padding))) {
                printf("overwrite head\n");
                hexdump(stderr, "Target", target, text_byte_len + 32);
                goto end;
        }
        if (memcmp(padding, target + sizeof(padding) + text_byte_len,
                   sizeof(padding))) {
                printf("overwrite tail\n");
                hexdump(stderr, "Target", target, text_byte_len + 32);
                goto end;
        }
        ret = 0;
end:
        if (target != NULL)
                free(target);
        return ret;
}

static int test_ctr_vectors(struct mb_mgr *mb_mgr, const struct gcm_ctr_vector *vectors,
                 	    const uint32_t vectors_cnt, const job_cipher_mode alg)
{
        uint32_t vect;
        int errors = 0;
        DECLARE_ALIGNED(uint32_t expkey[4*15], 16);
        DECLARE_ALIGNED(uint32_t dust[4*15], 16);
	int i;

        printf("AES-CTR standard test vectors:\n");
        for (vect = 0; vect < vectors_cnt; vect++) {
	switch (vectors[vect].Klen) {
                case BITS_128:
                        aes_keyexp_128_avx512(vectors[vect].K,
                                           expkey, dust);
                        break;
                case BITS_192:
                        aes_keyexp_192_avx512(vectors[vect].K,
                                           expkey, dust);
                        break;
                case BITS_256:
                        aes_keyexp_256_avx512(vectors[vect].K,
                                           expkey, dust);
                        break;
                default:
                        return -1;
        }
	if (test_ctr(mb_mgr, expkey, vectors[vect].Klen, vectors[vect].IV, (unsigned) vectors[vect].IVlen,
                     vectors[vect].P, vectors[vect].C, (unsigned) vectors[vect].Plen, IMB_DIR_ENCRYPT,
		     IMB_ORDER_CIPHER_HASH, alg)) {
		printf("error #%d encrypt\n", vect + 1);
		errors++;
	}
        if (test_ctr(mb_mgr, expkey, vectors[vect].Klen, vectors[vect].IV, (unsigned) vectors[vect].IVlen,
                     vectors[vect].C, vectors[vect].P, (unsigned) vectors[vect].Plen, IMB_DIR_DECRYPT,
		     IMB_ORDER_HASH_CIPHER, alg)) {
		printf("error #%d decrypt\n", vect + 1);
		errors++;
	}
	if (vectors[vect].IVlen == 12) {
                        const unsigned new_iv_len = 16;
                        const unsigned orig_iv_len = 12;
                        uint8_t local_iv[16];

                        memcpy(local_iv, vectors[vect].IV, orig_iv_len);
                        local_iv[12] = 0x00;
                        local_iv[13] = 0x00;
                        local_iv[14] = 0x00;
                        local_iv[15] = 0x01;

                        if (test_ctr(mb_mgr,
                                     expkey, vectors[vect].Klen,
                                     local_iv, new_iv_len,
                                     vectors[vect].P, vectors[vect].C,
                                     (unsigned) vectors[vect].Plen,
                                     IMB_DIR_ENCRYPT, IMB_ORDER_CIPHER_HASH,
                                     alg)) {
                                printf("error #%d encrypt\n", vect + 1);
                                errors++;
                        }
                        if (test_ctr(mb_mgr,
                                     expkey, vectors[vect].Klen,
                                     local_iv, new_iv_len,
                                     vectors[vect].C, vectors[vect].P,
                                     (unsigned) vectors[vect].Plen,
                                     IMB_DIR_DECRYPT, IMB_ORDER_HASH_CIPHER,
                                     alg)) {
                                printf("error #%d decrypt\n", vect + 1);
                                errors++;
                        }
              } 
	}
        printf("\n");
        return errors;
}	

int ctr_test(struct mb_mgr *mb_mgr)
{
	int errors;
	const uint32_t ctr_vec_cnt = DIM(ctr_vectors);
        const uint32_t ctr_bit_vec_cnt = DIM(ctr_bit_vectors);

	errors = test_ctr_vectors(mb_mgr, ctr_vectors, ctr_vec_cnt, IMB_CIPHER_CNTR);
	errors += test_ctr_vectors(mb_mgr, ctr_bit_vectors, ctr_bit_vec_cnt,
				   IMB_CIPHER_CNTR_BITLEN);

        if (0 == errors)
                printf("...Pass\n");
        else
                printf("...Fail\n");

        return errors;
}

static void *alloc_aligned_mem(const size_t size)
{
        void *ptr;

        const size_t alignment = 64;
        if (posix_memalign((void **)&ptr, alignment, size))
                return NULL;

        assert(ptr != NULL);

        memset(ptr, 0, size);

        return ptr;
}

static void free_mem(void *ptr)
{
        free(ptr);
}

int main()
{
	struct mb_mgr *ptr = NULL;

        ptr = alloc_aligned_mem(sizeof(struct mb_mgr));
        assert(ptr != NULL);
	if (ptr == NULL)
		return -1;

	ptr->earliest_job = -1;
	ptr->next_job = 0;

	ctr_test(ptr);

	free_mem(ptr);

	return 0;
}
